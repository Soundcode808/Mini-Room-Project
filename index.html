<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Miniroom: Reboot v1.9 (Digest Button & Zoom Limit)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

        body {
            margin: 0; overflow: hidden;
            background-color: #020205; color: #fff;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; user-select: none;
        }

        #gameCanvas { display: block; width: 100vw; height: 100vh; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 24px; box-sizing: border-box; z-index: 10;
        }

        /* HUD Styles */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: none; }
        .status-panel {
            pointer-events: auto; background: rgba(10, 15, 30, 0.85);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 229, 255, 0.3); border-left: 4px solid #00e5ff;
            padding: 20px; border-radius: 4px; min-width: 280px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-family: 'Orbitron', sans-serif; transition: all 0.3s ease;
        }
        .stat-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; font-size: 13px; }
        .label { color: #88aadd; font-size: 11px; font-weight: 500; text-transform: uppercase; }
        .value { color: #fff; font-weight: 700; text-shadow: 0 0 8px rgba(255, 255, 255, 0.3); }
        .bar-container { width: 100%; height: 6px; background: rgba(0,0,0,0.6); border-radius: 3px; margin-bottom: 12px; overflow: hidden; }
        .bar-fill { height: 100%; width: 0%; transition: width 0.1s; }
        .wp-fill { background: linear-gradient(90deg, #aa00ff, #d500f9); box-shadow: 0 0 10px #d500f9; }
        .aura-fill { background: linear-gradient(90deg, #ff6d00, #ffea00); box-shadow: 0 0 10px #ffea00; }
        .stamina-fill { background: linear-gradient(90deg, #00c853, #64dd17); box-shadow: 0 0 10px #64dd17; }

        /* Settings */
        #settings-toggle {
            pointer-events: auto; width: 48px; height: 48px;
            background: rgba(10, 15, 30, 0.8); border: 1px solid rgba(0, 229, 255, 0.4);
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-size: 24px; color: #00e5ff; cursor: pointer; transition: all 0.3s ease; z-index: 20;
        }
        #settings-toggle:hover { background: rgba(0, 229, 255, 0.15); transform: rotate(90deg); }

        #settings-panel {
            position: fixed; top: 0; right: 0; width: 320px; height: 100%;
            background: rgba(5, 8, 16, 0.95); border-left: 1px solid #00e5ff;
            box-shadow: -10px 0 40px rgba(0,0,0,0.8); padding: 80px 30px 30px;
            box-sizing: border-box; transform: translateX(100%); transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
            pointer-events: auto; z-index: 15; display: flex; flex-direction: column; gap: 24px;
        }
        #settings-panel.active { transform: translateX(0); }
        #settings-panel h3 { margin: 0 0 10px 0; color: #00e5ff; font-family: 'Orbitron', sans-serif; font-size: 18px; border-bottom: 2px solid rgba(0,229,255,0.2); padding-bottom: 12px; }
        .setting-group { display: flex; flex-direction: column; gap: 8px; }
        .setting-group label { color: #ccc; font-size: 12px; display: flex; justify-content: space-between; }
        
        input[type="range"] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type="range"]::-webkit-slider-runnable-track { width: 100%; height: 6px; background: #2a3b55; border-radius: 3px; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { height: 18px; width: 18px; border-radius: 50%; background: #00e5ff; margin-top: -6px; -webkit-appearance: none; cursor: pointer; box-shadow: 0 0 10px #00e5ff; }

        .action-btn {
            width: 100%; padding: 14px; background: rgba(0,229,255,0.05);
            border: 1px solid rgba(0,229,255,0.3); color: #00e5ff;
            font-family: 'Orbitron', sans-serif; font-size: 12px; font-weight: 700;
            text-transform: uppercase; cursor: pointer; transition: all 0.2s; border-radius: 4px;
        }
        .action-btn:hover { background: rgba(0,229,255,0.15); box-shadow: 0 0 20px rgba(0,229,255,0.2); }
        .action-btn.danger { border-color: #ff3d00; color: #ff3d00; background: rgba(255,61,0,0.05); }
        .action-btn.danger:hover { background: rgba(255,61,0,0.15); box-shadow: 0 0 20px rgba(255,61,0,0.2); }

        /* Notification */
        #notification {
            position: absolute; top: 25%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; text-align: center; font-family: 'Orbitron', sans-serif; font-weight: 900;
            font-size: 36px; color: #fff; text-shadow: 0 0 20px rgba(0,229,255,0.8);
            pointer-events: none; opacity: 0; transition: opacity 0.3s; z-index: 100;
        }

        .key-guide {
            position: absolute; bottom: 30px; left: 30px;
            color: rgba(255,255,255,0.4); font-size: 12px; line-height: 1.6;
            font-family: 'Orbitron', sans-serif; pointer-events: none;
        }

        /* Mobile Controls */
        #mobile-controls {
            display: none; /* Hidden by default */
            position: absolute; bottom: 20px; left: 20px; right: 20px;
            height: 150px; pointer-events: none;
            justify-content: space-between; align-items: center;
        }
        #mobile-controls.visible { display: flex; }
        
        .joystick-area {
            width: 120px; height: 120px; background: rgba(255,255,255,0.05);
            border: 2px solid rgba(255,255,255,0.1); border-radius: 50%;
            position: relative; pointer-events: auto; touch-action: none;
        }
        .joystick-knob {
            width: 50px; height: 50px; background: rgba(0,229,255,0.5);
            border-radius: 50%; position: absolute; top: 35px; left: 35px;
            box-shadow: 0 0 15px #00e5ff; pointer-events: none;
        }
        
        .action-buttons {
            display: flex; gap: 20px; pointer-events: auto;
        }
        .mob-btn {
            width: 80px; height: 80px; border-radius: 50%;
            background: rgba(0,0,0,0.5); border: 2px solid #888;
            color: #fff; font-family: 'Orbitron'; font-size: 14px; font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            touch-action: manipulation;
        }
        .mob-btn.digest { border-color: #d500f9; color: #d500f9; }
        .mob-btn.digest:active { background: rgba(213,0,249,0.3); }
        .mob-btn.sprint { border-color: #00c853; color: #00c853; }
        .mob-btn.sprint:active { background: rgba(0,200,83,0.3); }

        /* Opening */
        #opening-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; display: flex; justify-content: center; align-items: center;
            flex-direction: column; z-index: 9999; transition: opacity 0.8s;
        }
        .title-main { font-family: 'Orbitron', sans-serif; font-size: 5rem; color: #00e5ff; text-shadow: 0 0 60px rgba(0,229,255,0.6); margin: 0; }
        .title-sub { font-family:'Orbitron'; color:#fff; font-size:1.2rem; letter-spacing:8px; opacity:0.7; margin-top: 10px; margin-bottom: 50px; }
        .start-btn {
            padding: 18px 50px; background: transparent; border: 2px solid #00e5ff; color: #00e5ff;
            font-family: 'Orbitron', sans-serif; font-size: 20px; font-weight: 700; cursor: pointer;
            transition: all 0.3s; 
        }
        .start-btn:hover { background: #00e5ff; color: #020205; box-shadow: 0 0 50px rgba(0,229,255,0.8); }
        
        #aura-refill-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 70px; height: 70px; border-radius: 50%; 
            border: 2px solid rgba(255, 145, 0, 0.5);
            background: rgba(0,0,0,0.4); color: #ff9100; font-size: 28px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; pointer-events: auto; backdrop-filter: blur(4px);
            opacity: 0; transition: all 0.2s; z-index: 5;
        }
        #aura-refill-btn:hover { border-color: #ff9100; background: rgba(255, 145, 0, 0.2); box-shadow: 0 0 30px #ff9100; transform: scale(1.1); }
        #aura-refill-cost { position: absolute; bottom: -20px; width: 100%; text-align: center; font-size: 10px; color: #aaa; font-family: 'Orbitron'; }

        /* Digest Button */
        #digest-btn {
            pointer-events: auto;
            position: absolute; bottom: 120px; right: 30px; /* Above refill button */
            width: 60px; height: 60px; border-radius: 50%;
            border: 2px solid #d500f9;
            background: rgba(0,0,0,0.6); color: #d500f9; font-size: 24px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(4px);
            transition: all 0.2s; z-index: 5;
        }
        #digest-btn:hover { transform: scale(1.1); background: rgba(213, 0, 249, 0.2); box-shadow: 0 0 20px #d500f9; }
        #digest-btn:active { transform: scale(0.95); }
        #digest-label { font-size: 10px; font-family: 'Orbitron'; margin-top: 2px; }

    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div class="status-panel" id="status-panel" style="opacity: 0;">
                <div class="stat-row">
                    <span class="label">Vessel (WP)</span>
                    <span class="value"><span id="wp-val">0</span> / 100</span>
                </div>
                <div class="bar-container"><div id="wp-bar" class="bar-fill wp-fill"></div></div>

                <div class="stat-row">
                    <span class="label">Aura</span>
                    <span class="value" id="aura-text">100%</span>
                </div>
                <div class="bar-container"><div id="aura-bar" class="bar-fill aura-fill"></div></div>

                <div class="stat-row">
                    <span class="label">Stamina</span>
                    <span class="value" id="stamina-text">100%</span>
                </div>
                <div class="bar-container"><div id="stamina-bar" class="bar-fill stamina-fill"></div></div>

                <div style="margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;">
                    <div class="stat-row">
                        <span class="label">AP Rate</span>
                        <span class="value"><span id="ap-rate-val">0.0</span> /s</span>
                    </div>
                    <div class="stat-row">
                        <span class="label">CP Gain</span>
                        <span class="value"><span id="cp-gain-val">10</span> WP</span>
                    </div>
                    <div id="ap-streak-row">
                        <span class="label" style="color: #64dd17;">AP Streak</span>
                        <span>x<span id="ap-streak-count">0</span> (+<span id="ap-streak-bonus">0.0</span>%)</span>
                    </div>
                </div>
            </div>
            <div id="settings-toggle" onclick="app.toggleSettings()">‚öôÔ∏è</div>
        </div>

        <div id="settings-panel">
            <h3>Settings</h3>
            <div class="setting-group">
                <label>Volume <span id="val-volume">100%</span></label>
                <input type="range" id="sl-volume" min="0" max="100" value="100">
            </div>
            <div class="setting-group">
                <button onclick="app.toggleMute()" id="mute-btn" class="action-btn">üîä Sound On</button>
            </div>
            <div style="height: 1px; background: rgba(255,255,255,0.1); margin: 10px 0;"></div>
            <div class="setting-group">
                <button onclick="app.toggleMobileControls()" id="mob-ctrl-btn" class="action-btn">üì± Show Mobile Controls</button>
            </div>
            <div style="margin-top: auto;">
                <button onclick="app.resetGame()" class="action-btn danger">‚ö† World Reset</button>
            </div>
        </div>

        <div id="notification"></div>

        <div class="key-guide">
            [WASD/Mouse] Move &nbsp; [Space/.] Digest &nbsp; [Shift] Drift
        </div>

        <!-- Digest Button -->
        <div id="digest-btn" onmousedown="app.keys['.']=true" onmouseup="app.keys['.']=false" ontouchstart="app.keys['.']=true" ontouchend="app.keys['.']=false">
            <span>‚ôª</span>
        </div>

        <div id="aura-refill-btn" onclick="app.refillAura()">
            <span class="icon">‚ö°</span>
            <span class="cost" id="aura-refill-cost">1 WP</span>
        </div>

        <!-- Mobile Controls Overlay -->
        <div id="mobile-controls">
            <div class="joystick-area" id="joystick-area">
                <div class="joystick-knob" id="joystick-knob"></div>
            </div>
            <div class="action-buttons">
                <div class="mob-btn digest" id="btn-digest" ontouchstart="app.keys['.']=true" ontouchend="app.keys['.']=false">DIGEST</div>
                <div class="mob-btn sprint" id="btn-sprint" ontouchstart="app.keys['Shift']=true" ontouchend="app.keys['Shift']=false">DRIFT</div>
            </div>
        </div>
    </div>

    <div id="opening-overlay">
        <h1 class="title-main">MINIROOM</h1>
        <h2 class="title-sub">REBOOT: GRAVITY</h2>
        <button class="start-btn" onclick="app.startSequence()">INITIALIZE</button>
    </div>

<script>
/**
 * MINIROOM REBOOT v1.9 (Digest Button & Zoom Limit)
 * - FEATURE: Added visual 'Digest' button and mapped '.' key to digestion.
 * - TWEAK: Limited Max Zoom Out (0.45) for better visibility balance.
 */

class MiniroomApp {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        this.state = 'IDLE'; 
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.frameCount = 0;
        
        this.camera = { x: 0, y: 0, zoom: 1.0, targetZoom: 1.0 };
        this.viewTilt = 0.55; 
        
        this.physics = { accel: 1.5, friction: 0.96, brake: 0.92 };

        this.player = {
            x: 0, y: 0, vx: 0, vy: 0, 
            radius: 15, color: '#ffffff',
            aura: 100, maxAura: 100,
            stamina: 100, maxStamina: 100,
            state: 'NORMAL', resonanceTimer: 0, trailTimer: 0,
            apStreak: 0, apStreakTimeout: null,
            tail: [], path: []
        };

        this.rivals = [];
        this.wp = 0; this.apAccumulator = 0; this.maxWp = 100;
        
        this.stats = { speed: 0.25, maxSpeed: 13, sprintMult: 1.5, magnetRange: 200 };
        this.devSettings = { apGain: 1.0, cpGain: 10, auraDecay: 0.05 };

        this.particles = [];
        this.cubes = []; 
        this.shockwaves = [];
        this.sonarPulses = [];
        
        this.DIGESTION_RATE = 10;
        this.TAIL_SEGMENT_SPACING = 6;
        this.TRAIL_SPAWN_RATE = 120;

        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false, active: false };
        this.joystick = { active: false, dx: 0, dy: 0 };
        
        this.volume = 1.0;
        this.soundEnabled = true;
        this.sounds = {};
        this.flashIntensity = 0;
        
        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        window.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
        
        // Mouse Input
        this.canvas.addEventListener('mousemove', e => {
            this.mouse.x = e.clientX - this.width/2;
            this.mouse.y = e.clientY - this.height/2;
            this.mouse.active = true;
        });
        this.canvas.addEventListener('mousedown', () => { this.mouse.down = true; this.mouse.active = true; });
        this.canvas.addEventListener('mouseup', () => this.mouse.down = false);

        // Joystick Input
        this.initJoystick();

        this.bindSettings();
        this.initAudio();

        requestAnimationFrame(() => this.loop());

        for(let i=0; i<4; i++) this.spawnRival();
        for(let i=0; i<50; i++) this.spawnCubeRandomly();
    }

    initJoystick() {
        const zone = document.getElementById('joystick-area');
        const knob = document.getElementById('joystick-knob');
        let startX, startY;

        zone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = zone.getBoundingClientRect();
            startX = rect.left + rect.width/2;
            startY = rect.top + rect.height/2;
            this.updateJoystick(touch.clientX, touch.clientY, startX, startY, knob);
        });

        zone.addEventListener('touchmove', e => {
            e.preventDefault();
            const touch = e.touches[0];
            this.updateJoystick(touch.clientX, touch.clientY, startX, startY, knob);
        });

        zone.addEventListener('touchend', e => {
            e.preventDefault();
            this.joystick.active = false;
            this.joystick.dx = 0;
            this.joystick.dy = 0;
            knob.style.transform = `translate(0px, 0px)`;
        });
    }

    updateJoystick(cx, cy, sx, sy, knob) {
        const maxDist = 40;
        let dx = cx - sx;
        let dy = cy - sy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > maxDist) {
            dx = (dx/dist) * maxDist;
            dy = (dy/dist) * maxDist;
        }
        
        knob.style.transform = `translate(${dx}px, ${dy}px)`;
        
        this.joystick.active = true;
        this.joystick.dx = dx / maxDist;
        this.joystick.dy = dy / maxDist;
    }

    spawnRival() {
        this.rivals.push({
            x: (Math.random()-0.5)*3000, y: (Math.random()-0.5)*3000,
            vx: 0, vy: 0, radius: 15, hue: Math.random()*360, color: '#fff',
            moveTimer: 0, moveAngle: 0, state: 'NORMAL', resonanceTimer: 0,
            tail: [], path: []
        });
    }

    handleWheel(e) {
        if (this.state !== 'PLAY') return;
        e.preventDefault();
        // Zoom Limit Adjusted (0.45 min)
        this.camera.targetZoom = Math.max(0.45, Math.min(this.camera.targetZoom - e.deltaY * 0.001, 3.0));
    }

    initAudio() {
        this.sounds.bgm = new Audio('BGM.MP3');
        this.sounds.bgm.loop = true; 
        this.sounds.hit = new Audio('https://assets.codepen.io/21542/hit_hurt.mp3'); 
        this.sounds.pickup = new Audio('https://assets.codepen.io/21542/coin_collect.mp3'); 
        this.sounds.upgrade = new Audio('https://assets.codepen.io/21542/powerup.mp3'); 
        this.sounds.resonance = new Audio('https://assets.codepen.io/21542/explosion.mp3'); 
        this.setSoundVolumes();
    }
    
    setSoundVolumes() {
        const v = this.volume;
        if(this.sounds.bgm) this.sounds.bgm.volume = v * 0.3;
        if(this.sounds.hit) this.sounds.hit.volume = v * 0.5;
        if(this.sounds.pickup) this.sounds.pickup.volume = v * 0.4;
        if(this.sounds.upgrade) this.sounds.upgrade.volume = v * 0.5;
        if(this.sounds.resonance) this.sounds.resonance.volume = v * 0.7;
    }

    playSound(name) { 
        if (!this.soundEnabled) return;
        const sound = this.sounds[name];
        if (sound) { sound.currentTime=0; sound.play().catch(()=>{}); } 
    }

    toggleMute() {
        this.soundEnabled = !this.soundEnabled;
        document.getElementById('mute-btn').innerText = this.soundEnabled ? 'üîä Sound On' : 'üîá Muted';
        if (this.sounds.bgm) this.sounds.bgm.muted = !this.soundEnabled;
    }

    toggleSettings() {
        document.getElementById('settings-panel').classList.toggle('active');
    }

    toggleMobileControls() {
        const el = document.getElementById('mobile-controls');
        el.classList.toggle('visible');
        const btn = document.getElementById('mob-ctrl-btn');
        btn.innerText = el.classList.contains('visible') ? 'üì± Hide Mobile Controls' : 'üì± Show Mobile Controls';
    }

    bindSettings() {
        document.getElementById('sl-volume').addEventListener('input', e => {
            this.volume = e.target.value / 100;
            document.getElementById('val-volume').innerText = e.target.value + '%';
            this.setSoundVolumes();
        });
    }

    resize() {
        this.width = window.innerWidth; this.height = window.innerHeight;
        this.canvas.width = this.width; this.canvas.height = this.height;
    }
    
    startSequence() {
        if(this.soundEnabled && this.sounds.bgm) this.sounds.bgm.play().catch(()=>{});
        const overlay = document.getElementById('opening-overlay');
        overlay.style.opacity = 0;
        setTimeout(() => overlay.style.display = 'none', 800);
        
        this.state = 'PLAY';
        document.getElementById('status-panel').style.opacity=1;
        this.spawnShockwave(0,0,800, 1.5);
        this.showNotification("SYSTEM ONLINE");
    }

    loop() {
        this.frameCount++;
        
        this.ctx.fillStyle = '#020205';
        this.ctx.fillRect(0,0,this.width,this.height);

        if(this.state === 'PLAY') this.updatePlay();

        this.ctx.save();
        this.ctx.translate(this.width/2, this.height/2);
        
        if (this.shakeStrength > 0) {
            const dx = (Math.random()-0.5)*this.shakeStrength;
            const dy = (Math.random()-0.5)*this.shakeStrength;
            this.ctx.translate(dx, dy);
            this.shakeStrength *= 0.9;
            if(this.shakeStrength < 0.5) this.shakeStrength = 0;
        }

        this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.1;
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        
        this.ctx.scale(1, this.viewTilt);
        this.ctx.translate(-this.player.x, -this.player.y);

        this.drawGravityGrid();
        this.drawSonar();
        this.drawEntities();
        this.drawRivals();
        this.drawPlayer();
        this.drawParticles();
        this.drawShockwaves();

        this.ctx.restore();

        if(this.flashIntensity > 0) {
            this.ctx.fillStyle = `rgba(255, 255, 255, ${this.flashIntensity})`;
            this.ctx.fillRect(0,0,this.width,this.height);
            this.flashIntensity *= 0.85;
            if(this.flashIntensity < 0.01) this.flashIntensity = 0;
        }

        requestAnimationFrame(() => this.loop());
    }
    
    // --- Logic ---

    updateEntityTail(entity) {
        const currentHead = { x: entity.x, y: entity.y };
        if (entity.path.length === 0) entity.path.push(currentHead);
        else {
            const last = entity.path[0];
            const d = Math.sqrt((currentHead.x-last.x)**2 + (currentHead.y-last.y)**2);
            if (d >= 2) entity.path.unshift(currentHead); 
        }
        
        let pathDistance = 0;
        let segCount = 0;
        for (let i = 1; i < entity.path.length; i++) {
            if (segCount >= entity.tail.length) break;
            const p1 = entity.path[i - 1];
            const p2 = entity.path[i];
            const dist = Math.sqrt((p1.x-p2.x)**2 + (p1.y-p2.y)**2);
            pathDistance += dist;

            while (pathDistance >= this.TAIL_SEGMENT_SPACING && segCount < entity.tail.length) {
                const ratio = (pathDistance - this.TAIL_SEGMENT_SPACING) / dist;
                entity.tail[segCount].x = p1.x - (p1.x - p2.x) * ratio;
                entity.tail[segCount].y = p1.y - (p1.y - p2.y) * ratio;
                pathDistance -= this.TAIL_SEGMENT_SPACING;
                segCount++;
            }
        }

        while (entity.path.length > entity.tail.length * 5 + 50) entity.path.pop();
        
        // Manual Digestion for Player (Space or . key)
        if (entity === this.player && (this.keys['Space'] || this.keys['.']) && entity.tail.length > 0) {
            if (this.frameCount % 2 === 0) { // Fast consume
                entity.tail.pop();
                entity.stamina = Math.min(entity.maxStamina, entity.stamina + 2);
                this.spawnParticles(entity.x, entity.y, 1, '#00ff00', 'spark');
            }
        }
        // AI digestion
        if (entity !== this.player && entity.tail.length > 0 && this.frameCount % this.DIGESTION_RATE === 0) {
            entity.tail.pop();
        }
    }

    updatePlay() {
        let ax = 0, ay = 0;
        const accelForce = this.physics.accel;
        const maxS = (this.keys['Shift']||this.keys['ShiftRight']) ? this.stats.maxSpeed * this.stats.sprintMult : this.stats.maxSpeed;

        // Input Handling
        let dirX = 0, dirY = 0;

        if (this.keys['ArrowUp'] || this.keys['w']) dirY -= 1;
        if (this.keys['ArrowDown'] || this.keys['s']) dirY += 1;
        if (this.keys['ArrowLeft'] || this.keys['a']) dirX -= 1;
        if (this.keys['ArrowRight'] || this.keys['d']) dirX += 1;

        if (this.mouse.active && this.mouse.down && !this.keys['.']) { // Prevent moving if digest click
             const angle = Math.atan2(this.mouse.y * this.viewTilt, this.mouse.x);
             dirX = Math.cos(angle);
             dirY = Math.sin(angle);
        }

        if (this.joystick.active) {
            dirX = this.joystick.dx;
            dirY = this.joystick.dy;
        }

        const len = Math.sqrt(dirX*dirX + dirY*dirY);
        if (len > 0) {
            if(len>1 && !this.joystick.active) { dirX/=len; dirY/=len; } // Normalize unless analog joystick
            const mult = (this.keys['Shift'] || this.keys['ShiftRight']) ? 1.5 : 1.0;
            ax = dirX * accelForce * mult;
            ay = dirY * accelForce * mult;
        }

        this.player.vx += ax; this.player.vy += ay;

        const isMoving = (len > 0);
        const friction = isMoving ? this.physics.friction : this.physics.brake;
        this.player.vx *= friction; this.player.vy *= friction;

        const speed = Math.sqrt(this.player.vx**2 + this.player.vy**2);
        if (speed > maxS) {
            const r = maxS/speed;
            this.player.vx *= r; this.player.vy *= r;
        }

        if ((this.keys['Shift']||this.keys['ShiftRight']) && speed > 1) this.player.stamina = Math.max(0, this.player.stamina - 1.0);
        else this.player.stamina = Math.min(this.player.maxStamina, this.player.stamina + 0.5);

        if (this.player.state === 'RESONANCE') {
            this.player.resonanceTimer--;
            if(this.player.resonanceTimer <= 0) this.player.state = 'NORMAL';
        }

        this.player.x += this.player.vx; this.player.y += this.player.vy;

        this.updateEntityTail(this.player);
        
        this.player.trailTimer++;
        if (this.player.trailTimer >= this.TRAIL_SPAWN_RATE) {
            this.player.trailTimer = 0;
            this.spawnTrailCube(this.player.x, this.player.y);
        }

        if (speed > 0.1) {
            const streakBonus = Math.min(this.player.apStreak * 0.001, 0.05); 
            this.apAccumulator += (speed * 0.03 * this.devSettings.apGain) * (1 + streakBonus);
            if (this.apAccumulator >= 1) { this.addWP(1); this.apAccumulator--; }
        }
        if (this.player.apStreak > 0) {
            if (this.player.apStreakTimeout) clearTimeout(this.player.apStreakTimeout);
            this.player.apStreakTimeout = setTimeout(() => {
                this.player.apStreak = Math.max(0, this.player.apStreak - 1);
                this.updateUI();
            }, 3000);
        }
        if(this.player.aura > 0) this.player.aura = Math.max(0, this.player.aura - this.devSettings.auraDecay);

        if (this.frameCount % 60 === 0 && this.cubes.length < 60) this.spawnCubeNearPlayer();
        if (this.frameCount % 120 === 0) this.sonarPulses.push({x: this.player.x, y: this.player.y, r: 0, maxR: 700, alpha: 1});

        this.updateRivals();
        this.updateCubes();
        this.updateParticles();
        this.updateUI();
    }

    updateRivals() {
        this.rivals.forEach(r => {
            if (r.moveTimer <= 0) {
                r.moveTimer = Math.random() * 60 + 30;
                r.moveAngle = Math.random() * Math.PI * 2;
            }
            r.moveTimer--;
            
            const dx = this.player.x - r.x;
            const dy = this.player.y - r.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist < 600 && r.state === 'NORMAL') {
                r.vx += (dx/dist) * 0.35; r.vy += (dy/dist) * 0.35;
            } else {
                r.vx += Math.cos(r.moveAngle) * 0.2; r.vy += Math.sin(r.moveAngle) * 0.2;
            }
            r.vx *= 0.96; r.vy *= 0.96; 

            if (r.state === 'RESONANCE') {
                r.resonanceTimer--;
                if (r.resonanceTimer <= 0) r.state = 'NORMAL';
                r.color = '#ffaa00';
            } else {
                r.color = `hsl(${r.hue}, 80%, 60%)`;
            }

            r.x += r.vx; r.y += r.vy;
            this.updateEntityTail(r);

            r.trailTimer++;
            if (r.trailTimer >= this.TRAIL_SPAWN_RATE) {
                r.trailTimer = 0;
                this.spawnTrailCube(r.x, r.y);
            }

            this.checkHeadToTailCollision(this.player, r);
        });

        for (let i = 0; i < this.rivals.length; i++) {
            const r1 = this.rivals[i];
            const dP = Math.sqrt((r1.x-this.player.x)**2 + (r1.y-this.player.y)**2);
            if (dP < r1.radius + this.player.radius + 15) this.triggerResonance(r1, this.player);

            this.checkHeadToTailCollision(r1, this.player);

            for (let j = i + 1; j < this.rivals.length; j++) {
                const r2 = this.rivals[j];
                const dR = Math.sqrt((r1.x-r2.x)**2 + (r1.y-r2.y)**2);
                if (dR < r1.radius + r2.radius + 15) this.triggerResonance(r1, r2);
                
                this.checkHeadToTailCollision(r1, r2);
                this.checkHeadToTailCollision(r2, r1);
            }
        }
    }

    checkHeadToTailCollision(head, tailOwner) {
        if (head.state === 'RESONANCE' || tailOwner.state === 'RESONANCE') return;
        if (tailOwner.tail.length < 2) return;

        for (let k = 3; k < tailOwner.tail.length; k++) {
            const seg = tailOwner.tail[k];
            if(seg.x === undefined) continue;
            const dist = Math.sqrt((head.x - seg.x)**2 + (head.y - seg.y)**2);
            
            if (dist < head.radius + 12) { 
                this.scatterPoints(head); 
                this.triggerImpact(head, tailOwner.x, tailOwner.y); 
                return;
            }
        }
    }

    triggerResonance(a, b) {
        if (a.state === 'RESONANCE' || b.state === 'RESONANCE') {
            const angle = Math.atan2(a.y - b.y, a.x - b.x);
            a.vx += Math.cos(angle)*3; a.vy += Math.sin(angle)*3;
            b.vx -= Math.cos(angle)*3; b.vy -= Math.sin(angle)*3;
            return;
        }
        
        const mx = (a.x+b.x)/2; const my = (a.y+b.y)/2;
        this.spawnShockwave(mx, my, 700, 2.5); 
        this.spawnParticles(mx, my, 40, '#fff', 'spark'); 
        this.playSound('resonance');
        this.shakeStrength = 35;
        this.flashIntensity = 0.6; 

        if(a===this.player || b===this.player) this.showNotification("RESONANCE!!");

        a.state = b.state = 'RESONANCE';
        a.resonanceTimer = b.resonanceTimer = 60;

        const angle = Math.atan2(a.y - b.y, a.x - b.x);
        const force = 22;
        a.vx = Math.cos(angle)*force; a.vy = Math.sin(angle)*force;
        b.vx = -Math.cos(angle)*force; b.vy = -Math.sin(angle)*force;
    }

    triggerImpact(victim, sourceX, sourceY) {
        this.shakeStrength = 20;
        this.playSound('hit');
        this.spawnParticles(victim.x, victim.y, 25, '#ffaa00', 'spark');
        victim.state = 'RESONANCE'; victim.resonanceTimer = 40;
        const angle = Math.atan2(victim.y - sourceY, victim.x - sourceX);
        victim.vx = Math.cos(angle) * 15;
        victim.vy = Math.sin(angle) * 15;
    }

    scatterPoints(entity) {
        if(entity.tail.length === 0) return;
        
        this.showNotification(entity===this.player ? "CRASH! TAIL LOST" : "RIVAL CRASHED!");
        this.spawnShockwave(entity.x, entity.y, 500, 1.8);
        this.flashIntensity = 0.4;
        
        entity.tail.forEach(seg => {
            if(seg.x === undefined) return;
            this.spawnParticles(seg.x, seg.y, 3, seg.color || '#ffaa00', 'spark');
            this.cubes.push({
                x: seg.x + (Math.random()-0.5)*40,
                y: seg.y + (Math.random()-0.5)*40,
                size: 6, color: seg.color || '#ffaa00',
                vx: (Math.random()-0.5)*20, vy: (Math.random()-0.5)*20,
                angle: Math.random()*Math.PI, friction: 0.94
            });
        });
        entity.tail = [];
    }

    updateCubes() {
        this.cubes.forEach((c, i) => {
            if(c.vx) { c.x+=c.vx; c.y+=c.vy; c.vx*=c.friction; c.vy*=c.friction; }
            
            const dx = this.player.x - c.x;
            const dy = this.player.y - c.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if(dist < this.stats.magnetRange) {
                const f = (1 - dist/this.stats.magnetRange) * this.stats.speed * 2;
                c.x += (dx/dist) * f * 6;
                c.y += (dy/dist) * f * 6;
            }

            if(dist < this.player.radius + c.size + 15) {
                this.addWP(this.devSettings.cpGain);
                this.player.apStreak = Math.min(this.player.apStreak + 1, 50);
                this.playSound('pickup');
                this.spawnParticles(c.x, c.y, 15, c.color, 'burst');
                this.player.tail.push({color: c.color});
                this.cubes.splice(i, 1);
            }
        });
    }

    updateParticles() {
        for(let i=this.particles.length-1; i>=0; i--) {
            const p = this.particles[i];
            p.x += p.vx; p.y += p.vy;
            p.vx *= 0.92; p.vy *= 0.92; 
            p.life--;
            if(p.life <= 0) this.particles.splice(i, 1);
        }
    }

    spawnParticles(x, y, count, color, type = 'burst') {
        for(let i=0; i<count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = (type === 'spark' ? Math.random() * 20 + 5 : Math.random() * 10 + 2);
            this.particles.push({
                x: x, y: y,
                vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
                life: 30 + Math.random()*30,
                color: color,
                size: Math.random()*3 + 1,
                type: type
            });
        }
    }

    spawnShockwave(x, y, maxR, intensity = 1.0) {
        this.shockwaves.push({ x, y, r: 20, maxR, alpha: 1.0, intensity });
    }

    // --- Drawing ---

    drawGravityGrid() {
        const spacing = 130; 
        const limit = Math.ceil((Math.max(this.width, this.height)/this.camera.zoom)/spacing) + 4;
        const px = this.player.x; const py = this.player.y;
        
        const startX = Math.floor(px/spacing) - limit;
        const endX = startX + limit*2;
        const startY = Math.floor(py/spacing) - limit;
        const endY = startY + limit*2;

        this.ctx.lineWidth = 1.5;
        this.ctx.globalCompositeOperation = 'lighter'; 

        const getGridPoint = (ix, iy) => {
            let x = ix * spacing;
            let y = iy * spacing;
            
            const rx = (x - y) * 0.707;
            const ry = (x + y) * 0.707;
            x = rx; y = ry;

            let ox = x, oy = y;
            let totalIntensity = 0;

            const entities = [this.player, ...this.rivals];
            entities.forEach(e => {
                const dx = x - e.x; const dy = y - e.y;
                if (Math.abs(dx) < 600 && Math.abs(dy) < 600) {
                    const distSq = dx*dx + dy*dy;
                    if(distSq < 360000) { 
                        const t = Math.exp(-(distSq)/(2*(200)**2)); 
                        const angle = Math.atan2(dy, dx);
                        const force = t * 100; 
                        ox -= Math.cos(angle) * force * 0.5; 
                        oy -= Math.sin(angle) * force * 0.5;
                        totalIntensity += t;
                    }
                }
            });

            this.shockwaves.forEach(sw => {
                const dx = x - sw.x; const dy = y - sw.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const width = 120; 
                
                if (Math.abs(dist - sw.r) < width) {
                    const t = 1 - Math.abs(dist - sw.r)/width;
                    const wave = Math.sin((dist - sw.r) * 0.1) * 30 * sw.alpha * sw.intensity;
                    
                    const angle = Math.atan2(dy, dx);
                    ox += Math.cos(angle) * wave;
                    oy += Math.sin(angle) * wave;
                    totalIntensity += t * sw.intensity * 2.0;
                }
            });

            return {x: ox, y: oy, i: Math.min(totalIntensity, 2.0)};
        };

        for(let i=startX; i<=endX; i++) {
            for(let j=startY; j<=endY; j++) {
                const p = getGridPoint(i, j);
                if (i < endX) {
                    const pR = getGridPoint(i+1, j);
                    this.drawGridLine(p, pR);
                }
                if (j < endY) {
                    const pD = getGridPoint(i, j+1);
                    this.drawGridLine(p, pD);
                }
            }
        }
        
        this.ctx.shadowBlur = 0;
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawGridLine(p1, p2) {
        const avgI = (p1.i + p2.i) / 2;
        const r = Math.floor(0 + avgI * 200);
        const g = Math.floor(240 + avgI * 15); 
        const b = 255;
        const a = 0.15 + avgI * 0.6;
        
        this.ctx.strokeStyle = `rgba(${r},${g},${b},${a})`;
        this.ctx.lineWidth = 1.2 + avgI * 2; 
        this.ctx.shadowBlur = avgI * 15;
        this.ctx.shadowColor = `rgba(${r},${g},${b},${a})`;
        
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.stroke();
    }

    drawSonar() {
        this.ctx.save();
        this.ctx.scale(1, 1/this.viewTilt);
        this.ctx.globalCompositeOperation = 'lighter';

        for(let i=this.sonarPulses.length-1; i>=0; i--) {
            const p = this.sonarPulses[i];
            p.r += 12; p.alpha -= 0.015;
            if(p.alpha <= 0) { this.sonarPulses.splice(i, 1); continue; }

            this.ctx.strokeStyle = `rgba(0, 255, 255, ${p.alpha * 0.3})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            this.ctx.stroke();

            const checkEcho = (entity, color) => {
                const dx = entity.x - p.x; const dy = entity.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (Math.abs(dist - p.r) < 20 && p.alpha > 0.1) {
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowBlur = 15; this.ctx.shadowColor = color;
                    const angle = Math.atan2(dy, dx);
                    this.ctx.beginPath();
                    this.ctx.arc(entity.x, entity.y, entity.radius+10, angle-0.6, angle+0.6);
                    this.ctx.stroke();
                    this.ctx.shadowBlur = 0;
                }
            };
            this.cubes.forEach(c => checkEcho(c, 'rgba(0, 255, 255, 0.8)'));
            this.rivals.forEach(r => checkEcho(r, 'rgba(255, 50, 50, 0.8)'));
        }
        this.ctx.restore();
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawShockwaves() {
        this.ctx.save();
        this.ctx.scale(1, 1/this.viewTilt);
        this.ctx.globalCompositeOperation = 'lighter';
        for(let i=this.shockwaves.length-1; i>=0; i--) {
            const sw = this.shockwaves[i];
            sw.r += 25; // Fast expansion
            sw.alpha -= 0.03;
            if(sw.alpha <= 0) { this.shockwaves.splice(i, 1); continue; }
            
            this.ctx.lineWidth = 15 * sw.intensity;
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${sw.alpha * 0.8})`;
            this.ctx.beginPath();
            this.ctx.arc(sw.x, sw.y, sw.r, 0, Math.PI*2);
            this.ctx.stroke();
        }
        this.ctx.restore();
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawParticles() {
        this.ctx.save();
        this.ctx.scale(1, 1/this.viewTilt);
        this.ctx.globalCompositeOperation = 'lighter';
        this.particles.forEach(p => {
            this.ctx.fillStyle = p.color;
            this.ctx.globalAlpha = p.life / 60;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
            this.ctx.fill();
        });
        this.ctx.restore();
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawEntities() {
        this.ctx.globalCompositeOperation = 'lighter';
        this.cubes.forEach(c => {
            this.ctx.save();
            this.ctx.translate(c.x, c.y);
            this.ctx.scale(1, 1/this.viewTilt);
            this.ctx.shadowBlur = 25; this.ctx.shadowColor = c.color;
            this.ctx.fillStyle = c.color;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, c.size, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.restore();
        });
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawRivals() { this.drawChar(this.rivals); }
    drawPlayer() { this.drawChar([this.player]); }

    drawChar(list) {
        list.forEach(c => {
            this.ctx.save();
            this.ctx.globalCompositeOperation = 'lighter';
            
            // Tail
            if(c.tail.length > 0) {
                const total = c.tail.length;
                c.tail.forEach((seg, i) => {
                    if(seg.x===undefined) return;
                    this.ctx.save();
                    this.ctx.translate(seg.x, seg.y);
                    this.ctx.scale(1, 1/this.viewTilt);
                    
                    this.ctx.fillStyle = seg.color || c.color;
                    this.ctx.globalAlpha = 0.6; 
                    this.ctx.shadowBlur = 15; this.ctx.shadowColor = this.ctx.fillStyle;
                    
                    const radius = 8 + (total * 0.05); 

                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, radius, 0, Math.PI*2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
            this.ctx.restore();

            this.ctx.save();
            this.ctx.translate(c.x, c.y);
            this.ctx.scale(1, 1/this.viewTilt);
            
            this.ctx.globalAlpha = 0.9;
            this.ctx.shadowBlur = 40; this.ctx.shadowColor = c.color;
            this.ctx.fillStyle = c.state==='RESONANCE' ? '#fff' : c.color;
            
            this.ctx.beginPath();
            this.ctx.arc(0, 0, c.radius, 0, Math.PI*2);
            this.ctx.fill();
            
            this.ctx.fillStyle = '#fff';
            this.ctx.shadowBlur = 0;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 6, 0, Math.PI*2);
            this.ctx.fill();

            if(c.aura > 0) {
                this.ctx.strokeStyle = `rgba(0,255,255,${c.aura/200})`;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, c.radius+8, 0, Math.PI*2);
                this.ctx.stroke();
            }
            this.ctx.restore();
        });
    }

    spawnTrailCube(x, y) {
        this.cubes.push({ x, y, size: 5, color: '#ffff00', angle:0, vx:0, vy:0 });
    }
    spawnCubeRandomly() {
        this.cubes.push({ x: (Math.random()-0.5)*3000, y: (Math.random()-0.5)*3000, size:6, color:'#00ffff', angle:0, vx:0, vy:0 });
    }
    spawnCubeNearPlayer() { 
        const a = Math.random()*Math.PI*2; const d = 500 + Math.random()*200;
        this.cubes.push({ x: this.player.x+Math.cos(a)*d, y: this.player.y+Math.sin(a)*d, size:6, color:'#00ffff', angle:0, vx:0, vy:0 });
    }
    addWP(n) { if(this.wp<this.maxWp) this.wp = Math.min(this.wp+n, this.maxWp); }
    showNotification(t) { 
        const el = document.getElementById('notification');
        el.innerText = t; el.style.opacity = 1;
        clearTimeout(this.nt); this.nt = setTimeout(()=>el.style.opacity=0, 2000);
    }
    refillAura() { if(this.wp>=1){this.wp--;this.player.aura=this.player.maxAura;this.spawnShockwave(this.player.x,this.player.y,300);this.playSound('pickup');} }
    resetGame() { 
        this.wp=0; this.player.x=0; this.player.y=0; this.player.tail=[]; this.player.path=[];
        this.cubes=[]; for(let i=0;i<50;i++)this.spawnCubeRandomly(); 
        this.rivals.forEach(r => { r.x=(Math.random()-0.5)*2500; r.y=(Math.random()-0.5)*2500; r.tail=[]; r.path=[]; });
        this.showNotification("WORLD RESET"); 
    }
    updateUI() {
        const wpVal = document.getElementById('wp-val'); if(wpVal) wpVal.innerText = Math.floor(this.wp);
        const auraText = document.getElementById('aura-text'); if(auraText) auraText.innerText = Math.floor(this.player.aura) + '%';
        const staminaText = document.getElementById('stamina-text'); if(staminaText) staminaText.innerText = Math.floor(this.player.stamina) + '%';
        const streakCount = document.getElementById('ap-streak-count'); if(streakCount) streakCount.innerText = this.player.apStreak;
        const streakBonus = document.getElementById('ap-streak-bonus'); if(streakBonus) streakBonus.innerText = (Math.min(this.player.apStreak*0.001,0.05)*100).toFixed(1);
        
        const wpBar = document.getElementById('wp-bar'); if(wpBar) wpBar.style.width = (this.wp/this.maxWp)*100 + '%';
        const auraBar = document.getElementById('aura-bar'); if(auraBar) auraBar.style.width = this.player.aura + '%';
        const staminaBar = document.getElementById('stamina-bar'); if(staminaBar) staminaBar.style.width = this.player.stamina + '%';
        
        const speed = Math.sqrt(this.player.vx**2 + this.player.vy**2);
        const apRate = document.getElementById('ap-rate-val'); if(apRate) apRate.innerText = (speed*0.03*60).toFixed(2);
        
        const cpEl = document.getElementById('cp-gain-val');
        if(cpEl) cpEl.innerText = this.devSettings.cpGain;
    }
}

const app = new MiniroomApp();
</script>
</body>
</html>
