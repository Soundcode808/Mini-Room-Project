<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Miniroom Project: Reboot Prototype v1.3 (Tail System Fixed)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+KR:wght@300;500;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050814;
            color: #fff;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* UI Î†àÏù¥Ïñ¥ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        /* HUD */
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .status-panel {
            background: rgba(10, 20, 40, 0.85);
            border: 1px solid #00ffff;
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(8px);
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            pointer-events: auto;
            min-width: 250px;
        }

        .stat-row {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        /* AP STREAK */
        #ap-streak-row {
            margin-top: 10px;
            color: #64dd17;
            text-shadow: 0 0 5px rgba(100, 221, 23, 0.5);
            font-size: 10px;
        }

        .label { color: #aaa; font-size: 11px; }
        .value { color: #fff; font-weight: bold; font-size: 14px; }

        /* Í≤åÏù¥ÏßÄ Î∞î */
        .bar-container {
            width: 100%;
            height: 6px;
            background: #1a1a2e;
            margin-top: 4px;
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        
        .bar-fill { height: 100%; transition: width 0.1s; }
        .wp-fill { background: linear-gradient(90deg, #d500f9, #00e5ff); }
        .aura-fill { background: linear-gradient(90deg, #ff9100, #ffea00); }
        .stamina-fill { background: linear-gradient(90deg, #00c853, #64dd17); }

        .warning { animation: pulse-red 1s infinite; }
        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 rgba(255, 0, 0, 0); }
            50% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.8); }
            100% { box-shadow: 0 0 0 rgba(255, 0, 0, 0); }
        }

        /* ÏÑ§Ï†ï Ìå®ÎÑê */
        #settings-panel {
            background: rgba(8, 12, 24, 0.95);
            border-left: 2px solid #00e5ff;
            padding: 15px;
            width: 250px;
            pointer-events: auto;
            font-size: 12px;
            transform: translateX(110%);
            transition: transform 0.3s;
        }
        #settings-panel.active { transform: translateX(0); }
        #settings-panel h3 { color: #00e5ff; margin-top: 0; font-family: 'Orbitron', sans-serif; }
        .setting-group { margin-bottom: 15px; }
        .setting-group label { display: block; color: #ccc; margin-bottom: 4px; }
        .setting-group input[type="range"] { width: 100%; cursor: pointer; accent-color: #00e5ff; }
        .setting-val { float: right; color: #00e5ff; }

        /* ÏÑ§Ï†ï ÌÜ†Í∏Ä Î≤ÑÌäº */
        #settings-toggle {
            position: absolute; top: 20px; right: 20px;
            background: rgba(15, 25, 50, 0.9); border: 1px solid #00e5ff;
            color: #00e5ff; padding: 10px; border-radius: 50%;
            width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; pointer-events: auto; z-index: 100;
            box-shadow: 0 0 10px rgba(0, 229, 255, 0.2);
        }

        /* ÌïòÎã® ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê (Ï†úÍ±∞) */
        .upgrade-panel {
            height: 80px; 
            display: none; 
        }
        
        /* Ïò§ÌîÑÎãù Ïò§Î≤ÑÎ†àÏù¥ */
        #opening-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #050814;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            flex-direction: column;
        }

        .start-btn {
            padding: 15px 45px;
            background: transparent;
            border: 2px solid #00e5ff;
            color: #00e5ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.1);
        }

        .start-btn:hover {
            background: #00e5ff;
            color: #000;
            box-shadow: 0 0 40px rgba(0, 229, 255, 0.6);
        }
        
        #aura-refill-btn {
            position: absolute;
            bottom: 20px; 
            right: 20px;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            border: 2px solid #ff9100;
            background: rgba(0,0,0,0.6);
            color: #ff9100;
            font-size: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            opacity: 0;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 145, 0, 0.3);
        }
        #aura-refill-btn:hover { background: #ff9100; color: #000; box-shadow: 0 0 30px #ff9100; }
        #aura-refill-cost { position: absolute; bottom: -22px; width: 100%; text-align: center; font-size: 11px; color: #eee; text-shadow: 0 0 2px black; }

        .key-guide {
            position: absolute;
            bottom: 20px; 
            left: 20px;
            color: #667;
            font-size: 11px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        
        <div id="settings-toggle" onclick="app.toggleSettings()">‚öôÔ∏è</div>

        <div class="hud-top">
            <div class="status-panel" id="status-panel" style="opacity: 0;">
                <div class="stat-row">
                    <span class="label">VESSEL (WP)</span>
                    <span class="value"><span id="wp-val">0</span> / <span id="max-wp-val">100</span></span>
                </div>
                <div class="bar-container"><div id="wp-bar" class="bar-fill wp-fill" style="width: 0%"></div></div>
                <div style="height: 6px;"></div>
                
                <div class="stat-row">
                    <span class="label">AURA</span>
                    <span class="value" id="aura-text">100%</span>
                </div>
                <div class="bar-container"><div id="aura-bar" class="bar-fill aura-fill" style="width: 100%"></div></div>
                <div style="height: 6px;"></div>

                <div class="stat-row">
                    <span class="label">STAMINA</span>
                    <span class="value" id="stamina-text">100%</span>
                </div>
                <div class="bar-container"><div id="stamina-bar" class="bar-fill stamina-fill" style="width: 100%"></div></div>

                <div style="height: 6px;"></div>

                <!-- AP/CP ÌëúÏãú -->
                <div class="stat-row">
                    <span class="label">AP RATE (MOVE)</span>
                    <span class="value"><span id="ap-rate-val">0.00</span> / sec</span>
                </div>
                <div class="stat-row">
                    <span class="label">CP GAIN (COLLIDE)</span>
                    <span class="value"><span id="cp-gain-val">10</span> WP</span>
                </div>

                <div id="ap-streak-row" style="opacity: 0;">
                    AP Streak: <span id="ap-streak-count">0</span> (+<span id="ap-streak-bonus">0.0</span>%)
                </div>
            </div>

            <!-- ÏÑ§Ï†ï Ìå®ÎÑê -->
            <div id="settings-panel">
                <h3>‚öôÔ∏è SETTINGS / DEV</h3>
                <div class="setting-group">
                    <label>Volume <span id="val-volume" class="setting-val">100%</span></label>
                    <input type="range" id="sl-volume" min="0" max="100" step="1" value="100">
                </div>
                <div class="setting-group">
                    <button onclick="app.toggleMute()" id="mute-btn" style="width: 100%; padding: 8px; background: #223; color: #00e5ff; border: 1px solid #445; cursor: pointer; border-radius: 4px;">üîä Toggle Mute</button>
                </div>
                <div class="setting-group">
                    <label>AP Gain (Move) <span id="val-ap-gain" class="setting-val">1.0</span></label>
                    <input type="range" id="sl-ap-gain" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>
                <div class="setting-group">
                    <label>CP Gain (Collide) <span id="val-cp-gain" class="setting-val">10</span></label>
                    <input type="range" id="sl-cp-gain" min="1" max="50" step="1" value="10">
                </div>
                <div class="setting-group">
                    <button onclick="app.resetGame()" style="width: 100%; padding: 8px; background: #d500f9; color: #fff; border: 1px solid #d500f9; cursor: pointer; border-radius: 4px; font-weight: bold;">WORLD RESET</button>
                </div>
            </div>
        </div>

        <div id="notification"></div>
        <div id="aura-refill-btn" onclick="app.refillAura()">üí°<span id="aura-refill-cost">1 WP</span></div>
        <div class="key-guide">WASD / Arrow: Move<br>Shift (Hold): Sprint<br>Mouse Wheel: Zoom</div>

        <!-- ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê Ï†úÍ±∞ -->
        <div class="upgrade-panel" id="upgrade-panel"></div>
    </div>

    <div id="opening-overlay">
        <h1 style="font-family: 'Orbitron'; color: #00e5ff; font-size: 3.5rem; margin-bottom: 10px; text-shadow: 0 0 30px rgba(0, 229, 255, 0.8);">MINIROOM</h1>
        <h2 style="font-family: 'Orbitron'; color: #fff; font-size: 1.5rem; margin-top: 0; margin-bottom: 40px; letter-spacing: 5px; opacity: 0.8;">REBOOT: GRAVITY</h2>
        <p style="color: #889; margin-bottom: 40px; font-size: 0.9rem;">v1.3 (Tail System Fixed)</p>
        <button class="start-btn" onclick="app.startSequence()">INITIALIZE</button>
    </div>

<script>
/**
 * MINIROOM REBOOT: GRAVITY v1.3 (Tail System Fixed)
 * - FIX: Implemented robust Path History and segment assignment to fix tail movement.
 * - FIXED/CONFIRMED: Tail (Hose) system is fully operational for both Player and Rivals.
 * - REMOVED: Upgrade system (UI, stats, logic). Base values are now fixed.
 */

class MiniroomApp {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game State
        this.state = 'IDLE'; 
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.frameCount = 0;
        
        // Physics & World
        this.camera = { x: 0, y: 0, zoom: 1.0, targetZoom: 1.0 };
        this.friction = 0.94;
        this.viewTilt = 0.55; 
        
        // Player
        this.player = {
            x: 0, y: 0, vx: 0, vy: 0, 
            radius: 15, color: '#ffffff',
            aura: 100, maxAura: 100, auraRadius: 150,
            stamina: 100, maxStamina: 100,
            state: 'NORMAL',
            resonanceTimer: 0,
            trailTimer: 0,
            apStreak: 0,
            apStreakTimeout: null,
            tail: [], // Collected segment objects {color, x, y}
            path: []  // Head position history {x, y}
        };

        // Rivals (AI)
        this.rivals = [];

        // Economy
        this.wp = 0;
        this.apAccumulator = 0;
        this.maxWp = 100;
        
        // Stats (Fixed values)
        this.stats = {
            speed: 0.25,      // Base Movement Speed
            maxSpeed: 6,      // Base Max Speed
            sprintMult: 2.0,  // Sprint Multiplier
            vision: 1.0,      // Vision Range Multiplier
            magnetRange: 150, // Attraction Range (Fixed)
            magnetForce: 0.05 // Attraction Force (Fixed)
        };

        this.devSettings = { apGain: 1.0, cpGain: 10, auraDecay: 0.05 };

        // Objects
        this.gridSize = 100;
        this.particles = [];
        this.cubes = []; 
        this.shockwaves = [];
        this.sonarPulses = [];
        this.DIGESTION_RATE = 30; // 1 cube consumed every 30 frames (0.5 seconds)
        this.TAIL_SEGMENT_SPACING = 10; // Distance between segments on path
        this.TAIL_POINT_SIZE = 6;

        // Input
        this.keys = {};

        // Sound & Settings
        this.volume = 1.0;
        this.soundEnabled = true;
        this.settingsOpen = false;
        this.sounds = {};
        
        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => this.keys[e.key] = false);
        window.addEventListener('wheel', e => this.handleWheel(e), { passive: false });
        
        this.bindSettings();
        this.initAudio();

        requestAnimationFrame(() => this.loop());

        // Spawn Entities
        for(let i=0; i<4; i++) this.spawnRival();
        for(let i=0; i<40; i++) this.spawnCubeRandomly();
    }

    spawnRival() {
        this.rivals.push({
            x: (Math.random() - 0.5) * 2500, y: (Math.random() - 0.5) * 2500,
            vx: 0, vy: 0,
            radius: 15, color: `hsl(${Math.random()*360}, 70%, 50%)`, // Unique color for rivals
            moveTimer: 0, moveAngle: 0,
            state: 'NORMAL', resonanceTimer: 0, trailTimer: Math.random() * 420,
            tail: [], // Collected segment objects {color, x, y}
            path: []  // Head position history {x, y}
        });
    }

    handleWheel(e) {
        if (this.state !== 'PLAY') return;
        e.preventDefault();
        this.camera.targetZoom = Math.max(0.3, Math.min(this.camera.targetZoom - e.deltaY * 0.001, 3.0));
    }

    initAudio() {
        // Instantiate all Audio objects first
        this.sounds.bgm = new Audio('BGM.MP3');
        this.sounds.bgm.loop = true; 
        this.sounds.hit = new Audio('https://assets.codepen.io/21542/hit_hurt.mp3'); 
        this.sounds.pickup = new Audio('https://assets.codepen.io/21542/coin_collect.mp3'); 
        this.sounds.upgrade = new Audio('https://assets.codepen.io/21542/powerup.mp3'); 
        this.sounds.resonance = new Audio('https://assets.codepen.io/21542/explosion.mp3'); 
        
        // Then set volumes
        this.setSoundVolumes();
    }
    
    setSoundVolumes() {
        const effVolume = this.volume * 0.4;
        
        if (this.sounds.bgm) this.sounds.bgm.volume = this.volume * 0.25;
        if (this.sounds.hit) this.sounds.hit.volume = effVolume;
        if (this.sounds.pickup) this.sounds.pickup.volume = effVolume;
        if (this.sounds.upgrade) this.sounds.upgrade.volume = this.volume * 0.5;
        if (this.sounds.resonance) this.sounds.resonance.volume = this.volume * 0.6;
    }

    playSound(name) { 
        if (!this.soundEnabled) return;
        const sound = this.sounds[name];
        if (sound) { sound.currentTime=0; sound.play().catch(()=>{}); } 
    }

    toggleMute() {
        this.soundEnabled = !this.soundEnabled;
        document.getElementById('mute-btn').innerText = this.soundEnabled ? 'üîä Toggle Mute' : 'üîá Toggle Mute (Muted)';
        if (this.sounds.bgm) this.sounds.bgm.muted = !this.soundEnabled;
    }

    toggleSettings() {
        this.settingsOpen = !this.settingsOpen;
        document.getElementById('settings-panel').classList.toggle('active');
    }

    bindSettings() {
        document.getElementById('sl-volume').addEventListener('input', (e) => {
            this.volume = parseFloat(e.target.value) / 100;
            document.getElementById('val-volume').innerText = e.target.value + '%';
            this.setSoundVolumes();
        });

        document.getElementById('sl-ap-gain').addEventListener('input', e => { 
            this.devSettings.apGain = parseFloat(e.target.value); 
            document.getElementById('val-ap-gain').innerText = e.target.value; 
        });
        document.getElementById('sl-cp-gain').addEventListener('input', e => { 
            this.devSettings.cpGain = parseInt(e.target.value); 
            document.getElementById('val-cp-gain').innerText = e.target.value; 
        });
    }

    resize() {
        this.width = window.innerWidth; this.height = window.innerHeight;
        this.canvas.width = this.width; this.canvas.height = this.height;
    }
    
    startSequence() {
        if(this.soundEnabled) this.sounds.bgm.play().catch(()=>{});
        document.getElementById('opening-overlay').style.display='none';
        this.state = 'PLAY';
        document.getElementById('status-panel').style.opacity=1;
        document.getElementById('aura-refill-btn').style.opacity=1;
        this.spawnShockwave(0,0,500);
        this.showNotification("SYSTEM ONLINE");
    }

    loop() {
        this.frameCount++;
        this.ctx.clearRect(0,0,this.width,this.height);

        if(this.state === 'PLAY') this.updatePlay();

        this.ctx.save();
        this.ctx.translate(this.width/2, this.height/2);
        
        // Camera Shake
        if (this.shakeStrength > 0) {
            this.ctx.translate((Math.random()-0.5)*this.shakeStrength, (Math.random()-0.5)*this.shakeStrength);
            this.shakeStrength *= 0.9;
            if(this.shakeStrength < 0.5) this.shakeStrength = 0;
        }

        this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.1;
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        
        // Tilt World
        this.ctx.scale(1, this.viewTilt);
        this.ctx.translate(-this.player.x, -this.player.y);

        this.drawGravityGrid();
        this.drawEntities();
        this.drawRivals();
        this.drawPlayer();
        this.drawEffects();
        this.drawSonar();

        this.ctx.restore();
        requestAnimationFrame(() => this.loop());
    }
    
    // --- Tail Movement & Path Tracking Logic ---
    updateEntityTail(entity) {
        // 1. Update Head Position (Movement logic is applied to vx/vy before this call in updatePlay/updateRivals)
        entity.x += entity.vx; 
        entity.y += entity.vy;

        // 2. Path Tracking
        const currentHead = { x: entity.x, y: entity.y };
        
        if (entity.path.length === 0) {
            // Initialize path
            entity.path.push(currentHead);
        } else {
            const lastPathPoint = entity.path[0];
            const dx = currentHead.x - lastPathPoint.x;
            const dy = currentHead.y - lastPathPoint.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            // Add new path point only if the distance moved exceeds the spacing threshold
            if (dist >= this.TAIL_SEGMENT_SPACING) {
                entity.path.unshift(currentHead); 
            }
        }
        
        // 3. Assign Coordinates to Tail Segments (The collected objects)
        // Assign coordinates from the path history to the tail segments
        let segmentIndex = 0;
        
        // We iterate through the path to find the positions for the segments
        let pathDistance = 0;
        let segCount = 0;

        // The path points are stored in reverse order (index 0 is newest)
        // We assign segments starting from path index 1 (the neck)
        for (let i = 1; i < entity.path.length; i++) {
            if (segCount >= entity.tail.length) break;

            const p1 = entity.path[i - 1];
            const p2 = entity.path[i];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            pathDistance += dist;

            // Segment placement logic
            while (pathDistance >= this.TAIL_SEGMENT_SPACING && segCount < entity.tail.length) {
                const overshoot = pathDistance - this.TAIL_SEGMENT_SPACING;
                
                // Calculate position between p1 and p2
                const ratio = overshoot / dist;
                
                const segX = p1.x - dx * ratio;
                const segY = p1.y - dy * ratio;

                entity.tail[segCount].x = segX;
                entity.tail[segCount].y = segY;

                pathDistance -= this.TAIL_SEGMENT_SPACING; // Deduct one segment's worth of distance
                segCount++;
            }
        }

        // 4. Path Trimming: Keep path history length manageable, but always long enough for the tail
        const maxPathLength = entity.tail.length + 50; 
        while (entity.path.length > maxPathLength) {
            entity.path.pop();
        }

        // 5. Digestion
        if (entity.tail.length > 0 && this.frameCount % this.DIGESTION_RATE === 0) {
            entity.tail.pop(); // Consume 1 point from the end
        }
    }
    // --- End Tail Movement & Path Tracking Logic ---

    updatePlay() {
        // Player Movement Prep
        let ax = 0, ay = 0;
        let accel = this.stats.speed;
        let maxS = this.stats.maxSpeed;
        
        const isSprinting = (this.keys['Shift'] || this.keys['ShiftRight']) && this.player.stamina > 0;
        if (isSprinting) {
            accel *= 1.5;
            maxS *= this.stats.sprintMult;
            this.player.stamina = Math.max(0, this.player.stamina - 1);
        } else {
            this.player.stamina = Math.min(this.player.maxStamina, this.player.stamina + 0.5);
        }

        if (this.player.state === 'RESONANCE') {
            this.player.resonanceTimer--;
            if(this.player.resonanceTimer <= 0) this.player.state = 'NORMAL';
            accel *= 0.5; 
            maxS *= 0.5;
        }

        if (this.keys['ArrowUp'] || this.keys['w']) ay -= accel;
        if (this.keys['ArrowDown'] || this.keys['s']) ay += accel;
        if (this.keys['ArrowLeft'] || this.keys['a']) ax -= accel;
        if (this.keys['ArrowRight'] || this.keys['d']) ax += accel;

        this.player.vx += ax; this.player.vy += ay;
        this.player.vx *= this.friction; this.player.vy *= this.friction;

        const speed = Math.sqrt(this.player.vx**2 + this.player.vy**2);
        if (speed > maxS) {
            const r = maxS/speed;
            this.player.vx *= r; this.player.vy *= r;
        }
        
        // --- TAIL UPDATE ---
        this.updateEntityTail(this.player);
        // --- END TAIL UPDATE ---

        this.player.trailTimer++;
        if (this.player.trailTimer >= 420) {
            this.player.trailTimer = 0;
            this.spawnTrailCube(this.player.x, this.player.y);
        }

        // AP Gain (WP Streak Bonus Applied)
        if (speed > 0.1) {
            const streakBonus = Math.min(this.player.apStreak * 0.001, 0.05); 
            this.apAccumulator += (speed * 0.02 * this.devSettings.apGain) * (1 + streakBonus);
            
            if (this.apAccumulator >= 1) { this.addWP(1); this.apAccumulator--; }
        }

        // Streak Decay (5s = 300 frames)
        if (this.player.apStreakTimeout) clearTimeout(this.player.apStreakTimeout);
        if (this.player.apStreak > 0) {
            this.player.apStreakTimeout = setTimeout(() => {
                this.player.apStreak = Math.max(0, this.player.apStreak - 1);
                this.updateUI();
            }, 300 / 60 * 1000); 
        }

        // Aura Decay
        if(this.player.aura > 0) {
            this.player.aura -= this.devSettings.auraDecay;
            if(this.player.aura <= 0) this.player.aura = 0;
        }

        if (this.frameCount % 60 === 0 && this.cubes.length < 50) this.spawnCubeNearPlayer();

        this.updateRivals();
        this.updateCubes();

        if (this.frameCount % 120 === 0) {
            this.sonarPulses.push({x: this.player.x, y: this.player.y, r: 0, maxR: 600, alpha: 1});
        }

        this.updateUI();
    }

    updateRivals() {
        this.rivals.forEach(rival => {
            // AI Logic: Simple movement and player aggro
            if (rival.moveTimer <= 0) {
                rival.moveTimer = Math.random() * 60 + 30;
                rival.moveAngle = Math.random() * Math.PI * 2;
            }
            rival.moveTimer--;
            
            const dxp = this.player.x - rival.x;
            const dyp = this.player.y - rival.y;
            const distP = Math.sqrt(dxp*dxp + dyp*dyp);
            
            // Movement
            if (distP < 400 && rival.state === 'NORMAL') {
                rival.vx += (dxp/distP) * 0.2; rival.vy += (dyp/distP) * 0.2;
            } else {
                rival.vx += Math.cos(rival.moveAngle) * 0.1; rival.vy += Math.sin(rival.moveAngle) * 0.1;
            }

            rival.vx *= 0.95; rival.vy *= 0.95;

            // Resonance/Slowdown
            let accel_mult = 1.0;
            if (rival.state === 'RESONANCE') {
                rival.resonanceTimer--;
                if (rival.resonanceTimer <= 0) { rival.state = 'NORMAL'; rival.color = `hsl(${rival.hue}, 70%, 50%)`; } 
                else { rival.color = '#ffaa00'; accel_mult = 0.5; }
            }
            
            // Apply velocity * slowdown
            rival.vx *= accel_mult;
            rival.vy *= accel_mult;

            // --- TAIL UPDATE ---
            this.updateEntityTail(rival);
            // --- END TAIL UPDATE ---

            // Rival Trail
            rival.trailTimer++;
            if (rival.trailTimer >= 420) {
                rival.trailTimer = 0;
                this.spawnTrailCube(rival.x, rival.y);
            }

            // Player Head to Rival Tail Collision
            this.checkHeadToTailCollision(this.player, rival);
        });

        // Rival Head to Rival Tail & Rival Head to Player Tail Collision
        for (let i = 0; i < this.rivals.length; i++) {
            const rival = this.rivals[i];
            
            // Rival Head to Player Tail
            this.checkHeadToTailCollision(rival, this.player);

            // Rival Head to Rival Tail (other rivals)
            for (let j = i + 1; j < this.rivals.length; j++) {
                const otherRival = this.rivals[j];
                this.checkHeadToTailCollision(rival, otherRival);
                this.checkHeadToTailCollision(otherRival, rival); // Check both ways
            }
            
            // Rival Head to Rival Head
            for (let j = i + 1; j < this.rivals.length; j++) {
                const otherRival = this.rivals[j];
                const dx = rival.x - otherRival.x;
                const dy = rival.y - otherRival.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < rival.radius + otherRival.radius + 10) {
                    this.triggerResonance(rival, otherRival);
                }
            }
        }
    }
    
    checkHeadToTailCollision(headEntity, tailEntity) {
        if (headEntity.state === 'RESONANCE' || tailEntity.state === 'RESONANCE') return;
        if (tailEntity.tail.length === 0) return;

        const headRadius = headEntity.radius;

        // Check head vs tail segments
        // We use the coordinates assigned to the tail objects in updateEntityTail
        for (let i = 0; i < tailEntity.tail.length; i++) {
            const segment = tailEntity.tail[i];
            
            // Check only if segment has assigned coordinates
            if (segment.x === undefined) continue;
            
            const segSize = this.TAIL_POINT_SIZE; 
            const dx = headEntity.x - segment.x;
            const dy = headEntity.y - segment.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < headRadius + segSize) {
                // Head hits Tail: Head loses all its points
                this.scatterPoints(headEntity);
                
                // Knockback and slow effect 
                this.triggerHeadHitEffect(headEntity, tailEntity);
                
                // Important: Only trigger once per frame per entity pair
                return;
            }
        }
    }

    triggerHeadHitEffect(headEntity, tailEntity) {
        headEntity.state = 'RESONANCE';
        headEntity.resonanceTimer = 60; // Shorter stun for tail hits
        
        // Simple repel
        const dx = headEntity.x - tailEntity.x;
        const dy = headEntity.y - tailEntity.y;
        const angle = Math.atan2(dy, dx);
        const power = 10;
        headEntity.vx = Math.cos(angle) * power;
        headEntity.vy = Math.sin(angle) * power;
        
        this.shakeStrength = 10;
        this.playSound('hit'); 
    }

    scatterPoints(entity) {
        if (entity.tail.length === 0) return;
        
        this.showNotification(entity === this.player ? "TAIL LOST!" : "RIVAL TAIL LOST!");
        
        // Scatter all points from the tail
        entity.tail.forEach(seg => {
            this.cubes.push({
                x: seg.x + (Math.random()-0.5)*10,
                y: seg.y + (Math.random()-0.5)*10,
                size: this.TAIL_POINT_SIZE, angle: Math.random()*Math.PI, color: seg.color || '#ffaa00',
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                friction: 0.92
            });
        });
        
        entity.tail = []; // Empty the tail
        entity.path = []; // Reset path history
    }

    triggerResonance(entityA, entityB) {
        if (entityA.state === 'RESONANCE' || entityB.state === 'RESONANCE') {
            // Repel
            const dx = entityA.x - entityB.x;
            const dy = entityA.y - entityB.y;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const force = 5;
            entityA.vx += (dx/dist)*force; entityA.vy += (dy/dist)*force;
            entityB.vx -= (dx/dist)*force; entityB.vy -= (dy/dist)*force;
            return;
        }

        // Head to Head: Resonance/Knockback, NO point loss
        this.shakeStrength = 25;
        this.playSound('resonance');
        const midX = (entityA.x+entityB.x)/2;
        const midY = (entityA.y+entityB.y)/2;
        this.spawnShockwave(midX, midY, 400);

        if (entityA === this.player || entityB === this.player) this.showNotification("RESONANCE DETECTED!");

        entityA.state = 'RESONANCE'; entityA.resonanceTimer = 180;
        entityB.state = 'RESONANCE'; entityB.resonanceTimer = 180;

        const dx = entityA.x - entityB.x;
        const dy = entityA.y - entityB.y;
        const angle = Math.atan2(dy, dx);
        const power = 18;
        entityA.vx = Math.cos(angle) * power; entityA.vy = Math.sin(angle) * power;
        entityB.vx = -Math.cos(angle) * power; entityB.vy = -Math.sin(angle) * power;
    }

    updateCubes() {
        this.cubes.forEach((cube, i) => {
            if (cube.vx) {
                cube.x += cube.vx; cube.y += cube.vy;
                cube.vx *= (cube.friction||0.9); cube.vy *= (cube.friction||0.9);
            }

            const dx = this.player.x - cube.x;
            const dy = this.player.y - cube.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Smoother Magnet Logic
            if (dist < this.stats.magnetRange) {
                const pullPower = this.stats.magnetForce * 20; 
                const moveStep = Math.min(dist * 0.1, pullPower);
                
                cube.x += (dx/dist) * moveStep;
                cube.y += (dy/dist) * moveStep;
            }

            // Collect
            if (dist < this.player.radius + cube.size + 2) {
                this.addWP(this.devSettings.cpGain);
                this.player.apStreak = Math.min(this.player.apStreak + 1, 50);
                this.playSound('pickup');
                this.spawnShockwave(cube.x, cube.y, 40);
                
                // Add to tail instead of removing immediately
                this.player.tail.push({ color: cube.color }); // x, y will be assigned by path tracking
                this.cubes.splice(i, 1); // Remove from world
                
                return;
            }
        });
    }

    // --- Drawing ---

    drawGravityGrid() {
        const spacing = 100;
        const viewportDiagonal = Math.sqrt(this.width**2 + this.height**2);
        const limit = Math.ceil(viewportDiagonal / this.camera.zoom / spacing / this.viewTilt * 0.707) + 5;
        const playerX = this.player.x;
        const playerY = this.player.y;

        const startX = Math.floor(playerX / spacing) - limit;
        const endX = startX + limit * 2;
        const startY = Math.floor(playerY / spacing) - limit;
        const endY = startY + limit * 2;

        this.ctx.lineWidth = 1.2;
        this.ctx.strokeStyle = 'rgba(0, 240, 255, 0.25)'; 

        const distort = (x, y) => {
            const dx = x - playerX;
            const dy = y - playerY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const pullRadius = 500;
            if (dist < pullRadius) {
                const strength = (1 - dist/pullRadius) * 80;
                const angle = Math.atan2(dy, dx);
                return {
                    x: x - Math.cos(angle) * strength,
                    y: y - Math.sin(angle) * strength
                };
            }
            return {x, y};
        };

        for (let i = startX; i <= endX; i++) {
            for (let j = startY; j <= endY; j++) {
                const p1 = {x: i*spacing, y: j*spacing};
                
                const rot = (p) => {
                    const r = 0.707; 
                    return { x: (p.x - p.y) * r, y: (p.x + p.y) * r };
                };

                const rp1 = rot(p1);
                const dp1 = distort(rp1.x, rp1.y);

                const pRight = {x: (i+1)*spacing, y: j*spacing};
                const rpRight = rot(pRight);
                const dpRight = distort(rpRight.x, rpRight.y);
                
                const pDown = {x: i*spacing, y: (j+1)*spacing};
                const rpDown = rot(pDown);
                const dpDown = distort(rpDown.x, rpDown.y);

                this.ctx.beginPath();
                this.ctx.moveTo(dp1.x, dp1.y);
                this.ctx.lineTo(dpRight.x, dpRight.y);
                this.ctx.stroke();

                this.ctx.beginPath();
                this.ctx.moveTo(dp1.x, dp1.y);
                this.ctx.lineTo(dpDown.x, dpDown.y);
                this.ctx.stroke();
            }
        }
    }

    drawSonar() {
        this.ctx.save();
        this.ctx.scale(1, 1/this.viewTilt);
        
        this.sonarPulses.forEach((p, idx) => {
            p.r += 12;
            p.alpha -= 0.02;
            if(p.alpha <= 0) { this.sonarPulses.splice(idx, 1); return; }

            this.ctx.strokeStyle = `rgba(0, 255, 255, ${p.alpha * 0.4})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
            this.ctx.stroke();

            const checkEcho = (entity, color) => {
                const dx = entity.x - p.x;
                const dy = entity.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (Math.abs(dist - p.r) < 20 && p.alpha > 0.1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 3;
                    const angle = Math.atan2(dy, dx);
                    this.ctx.arc(entity.x, entity.y, entity.size ? entity.size + 15 : 30, angle - 0.6, angle + 0.6);
                    this.ctx.stroke();
                }
            };
            this.cubes.forEach(c => checkEcho(c, 'rgba(0, 255, 255, 0.6)'));
            this.rivals.forEach(r => checkEcho(r, 'rgba(255, 50, 50, 0.6)'));
        });
        
        this.ctx.restore();
    }
    
    drawTail(entity) {
        if (entity.tail.length === 0) return;

        this.ctx.globalAlpha = 0.5; // Semi-transparent hose
        this.ctx.shadowBlur = 15;
        
        // Draw each segment using the assigned coordinates
        entity.tail.forEach((seg, index) => {
            // Check if coordinates are valid before drawing
            if (seg.x === undefined || seg.y === undefined) return;

            const alpha = 0.5 * (1 - index / entity.tail.length);
            this.ctx.globalAlpha = alpha;
            this.ctx.shadowColor = seg.color || entity.color;
            this.ctx.fillStyle = seg.color || entity.color;
            
            const radius = this.TAIL_POINT_SIZE;
            this.ctx.beginPath();
            this.ctx.arc(seg.x, seg.y, radius, 0, Math.PI * 2);
            this.ctx.fill();
        });

        this.ctx.globalAlpha = 1.0;
        this.ctx.shadowBlur = 0;
    }

    drawRivals() {
        this.rivals.forEach(r => {
            // Draw tail first
            this.ctx.save();
            this.ctx.scale(1, 1/this.viewTilt);
            this.drawTail(r);
            this.ctx.restore();

            this.ctx.save();
            this.ctx.translate(r.x, r.y);
            this.ctx.scale(1, 1/this.viewTilt);

            // Shadow
            this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
            this.ctx.beginPath();
            this.ctx.ellipse(0, 20, 15, 8, 0, 0, Math.PI*2);
            this.ctx.fill();

            this.ctx.globalAlpha = 0.85; 
            this.ctx.fillStyle = r.color;
            this.ctx.shadowBlur = 15; this.ctx.shadowColor = r.color;
            this.ctx.beginPath();
            
            if (r.state === 'RESONANCE') {
                const shake = (Math.random()-0.5)*5;
                this.ctx.arc(shake, shake, r.radius, 0, Math.PI*2);
            } else {
                this.ctx.arc(0, 0, r.radius, 0, Math.PI*2);
            }
            this.ctx.fill();
            
            this.ctx.globalAlpha = 1.0;
            this.ctx.fillStyle = '#fff';
            this.ctx.beginPath();
            this.ctx.arc(0, 0, 5, 0, Math.PI*2);
            this.ctx.fill();
            this.ctx.restore();
        });
    }

    drawPlayer() {
        // Draw tail first
        this.ctx.save();
        this.ctx.scale(1, 1/this.viewTilt);
        this.drawTail(this.player);
        this.ctx.restore();

        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.scale(1, 1/this.viewTilt);

        // Shadow
        this.ctx.fillStyle = 'rgba(0,0,0,0.5)';
        this.ctx.beginPath();
        this.ctx.ellipse(0, 20, 15, 8, 0, 0, Math.PI*2);
        this.ctx.fill();

        this.ctx.globalAlpha = 0.85; 
        this.ctx.fillStyle = this.player.state === 'RESONANCE' ? '#ffaa00' : '#fff';
        this.ctx.shadowBlur = this.player.aura > 0 ? 40 : 10;
        this.ctx.shadowColor = this.player.state === 'RESONANCE' ? '#ffaa00' : '#00e5ff';
        
        const shakeX = this.player.state === 'RESONANCE' ? (Math.random()-0.5)*5 : 0;
        const shakeY = this.player.state === 'RESONANCE' ? (Math.random()-0.5)*5 : 0;

        this.ctx.beginPath();
        this.ctx.arc(shakeX, shakeY, this.player.radius, 0, Math.PI*2);
        this.ctx.fill();
        
        this.ctx.globalAlpha = 1.0;
        if (this.player.aura > 0) {
            this.ctx.strokeStyle = `rgba(0, 229, 255, ${this.player.aura/100})`;
            this.ctx.lineWidth = 2;
            this.ctx.beginPath();
            this.ctx.arc(0, 0, this.player.radius + 5 + Math.sin(Date.now()/100)*2, 0, Math.PI*2);
            this.ctx.stroke();
        }
        this.ctx.restore();
    }

    drawEntities() {
        this.cubes.forEach(cube => {
            this.ctx.save();
            this.ctx.translate(cube.x, cube.y);
            this.ctx.scale(1, 1/this.viewTilt);
            
            this.ctx.shadowBlur = 30; 
            this.ctx.shadowColor = cube.color;
            this.ctx.fillStyle = cube.color;
            
            this.ctx.beginPath();
            this.ctx.arc(0, 0, cube.size/2, 0, Math.PI*2);
            this.ctx.fill();

            this.ctx.shadowBlur = 0; 
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 1;
            const s = cube.size;
            this.ctx.rotate(cube.angle || 0);
            this.ctx.strokeRect(-s/2, -s/2, s, s);
            this.ctx.rotate(-(cube.angle||0)*2);
            this.ctx.strokeRect(-s/2, -s/2, s, s);

            this.ctx.restore();
        });
    }

    drawEffects() {
        this.shockwaves.forEach((sw, i) => {
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${sw.alpha})`;
            this.ctx.lineWidth = 2 + (1-sw.alpha)*10;
            this.ctx.beginPath();
            this.ctx.ellipse(sw.x, sw.y, sw.r, sw.r*this.viewTilt, 0, 0, Math.PI*2); 
            this.ctx.stroke();
            sw.r += 12; sw.alpha -= 0.03;
            if(sw.alpha<=0) this.shockwaves.splice(i,1);
        });
    }

    // --- Helpers ---
    spawnShockwave(x,y,maxR) { this.shockwaves.push({x,y,r:10, maxR, alpha:1}); }
    addWP(n) { if(this.wp<this.maxWp) this.wp = Math.min(this.wp+n, this.maxWp); else { const b=document.getElementById('wp-bar'); b.classList.add('warning'); setTimeout(()=>b.classList.remove('warning'),500); } }
    showNotification(t) { const el=document.getElementById('notification'); el.innerText=t; el.style.opacity=1; clearTimeout(this.nt); this.nt=setTimeout(()=>el.style.opacity=0, 2000); }
    spawnCubeNearPlayer() { 
        const angle = Math.random()*Math.PI*2; const dist = 400 + Math.random()*200;
        this.cubes.push({ x: this.player.x+Math.cos(angle)*dist, y: this.player.y+Math.sin(angle)*dist, size:6, color:'#00ffff', angle:Math.random() });
    }
    spawnCubeRandomly() {
        this.cubes.push({ x: (Math.random()-0.5)*3000, y: (Math.random()-0.5)*3000, size:6, color:'#00ffff', angle:Math.random() });
    }
    spawnTrailCube(x, y) {
        this.cubes.push({ 
            x: x + (Math.random()-0.5)*10, y: y + (Math.random()-0.5)*10,
            size: 4, color: '#ffff00', angle: Math.random() * Math.PI, vx: 0, vy: 0 
        });
    }
    resetCube(c) {
        // Respawn collected cube
        const angle = Math.random()*Math.PI*2; const dist = 1000 + Math.random()*500;
        c.x = this.player.x+Math.cos(angle)*dist; c.y = this.player.y+Math.sin(angle)*dist;
        c.vx = 0; c.vy = 0;
        c.color = '#00ffff';
        c.size = 6;
    }
    refillAura() { if(this.wp>=1){this.wp--;this.player.aura=this.player.maxAura;this.spawnShockwave(this.player.x,this.player.y,100);this.playSound('pickup');} else this.showNotification("NO WP"); }
    resetGame() { 
        this.wp=0; this.player.x=0; this.player.y=0; this.player.apStreak = 0; this.player.tail = []; this.player.path = [];
        this.cubes=[]; for(let i=0;i<40;i++)this.spawnCubeRandomly(); 
        this.rivals.forEach(r => { 
            r.x=(Math.random()-0.5)*2500; 
            r.y=(Math.random()-0.5)*2500; 
            r.tail=[]; 
            r.path=[];
            r.color = `hsl(${Math.random()*360}, 70%, 50%)`; 
        }); 
        this.showNotification("WORLD RESET"); 
    }
    updateUI() {
        const apBonus = Math.min(this.player.apStreak * 0.001 * 100, 5).toFixed(1);
        const streakEl = document.getElementById('ap-streak-row');

        document.getElementById('wp-val').innerText = Math.floor(this.wp);
        document.getElementById('aura-text').innerText = Math.floor(this.player.aura) + '%';
        document.getElementById('stamina-text').innerText = Math.floor(this.player.stamina) + '%';
        document.getElementById('ap-streak-count').innerText = this.player.apStreak;
        document.getElementById('ap-streak-bonus').innerText = apBonus;
        
        const speed = Math.sqrt(this.player.vx**2 + this.player.vy**2);
        const streakBonusValue = Math.min(this.player.apStreak * 0.001, 0.05); 
        const apRatePerSecond = speed > 0.1 
            ? (speed * 0.02 * this.devSettings.apGain * (1 + streakBonusValue)) * 60
            : 0;

        document.getElementById('ap-rate-val').innerText = apRatePerSecond.toFixed(2);
        document.getElementById('cp-gain-val').innerText = this.devSettings.cpGain;

        streakEl.style.opacity = this.player.apStreak > 0 ? 1 : 0;
        streakEl.style.color = apBonus > 0 ? '#64dd17' : '#888';

        document.getElementById('wp-bar').style.width = (this.wp/this.maxWp)*100 + '%';
        document.getElementById('aura-bar').style.width = this.player.aura + '%';
        document.getElementById('stamina-bar').style.width = this.player.stamina + '%';
    }
}

const app = new MiniroomApp();
</script>
</body>
</html>
