<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Miniroom: Neon Tesseract 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; overflow: hidden;
            background-color: #050510;
            font-family: 'Orbitron', sans-serif;
            user-select: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top HUD Left */
        .hud-left-container {
            display: flex; flex-direction: column; gap: 10px;
            align-items: flex-start;
            pointer-events: auto; /* 버튼 클릭을 위해 */
        }

        .stats-box {
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid rgba(0, 229, 255, 0.8);
            padding: 12px; border-radius: 8px;
            backdrop-filter: blur(5px);
            color: #00e5ff;
            min-width: 140px;
            box-shadow: 0 0 15px rgba(0, 229, 255, 0.2);
        }
        .stat-row { 
            display: flex; justify-content: space-between; gap: 15px; 
            margin-bottom: 4px; font-size: 13px; align-items: center;
        }
        .stat-val { font-weight: 700; color: #fff; }
        .stat-sub { font-size: 10px; color: #aaa; }
        
        /* New Stats Colors */
        .stat-ap { color: #00ff88; }
        .stat-cp { color: #ff00ff; }
        .stat-wp { color: #ffff00; text-shadow: 0 0 10px #ffff00; }

        .skill-status {
            font-size: 11px; color: #ff0055; margin-top: 5px; text-align: right;
            font-weight: bold;
        }
        
        .gauge-group {
            display: flex; flex-direction: column; gap: 3px;
            justify-content: center;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .progress-bar {
            height: 4px; 
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            width: 100px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .progress-fill {
            height: 100%; width: 0%;
            transition: width 0.2s;
            box-shadow: 0 0 5px currentColor;
        }

        .user-count {
            margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.2);
            padding-top: 5px; text-align: center; color: #aaa; font-size: 11px;
        }

        /* Settings Button & Panel */
        .settings-btn {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid #00e5ff;
            color: #00e5ff; padding: 8px 15px;
            font-family: 'Orbitron'; font-size: 12px;
            cursor: pointer; border-radius: 5px;
            transition: 0.2s;
            display: flex; align-items: center; gap: 5px;
        }
        .settings-btn:hover { background: #00e5ff; color: #000; }

        .settings-panel {
            background: rgba(0, 10, 20, 0.95);
            border: 1px solid #00e5ff;
            padding: 15px; border-radius: 8px;
            margin-top: 5px;
            display: none; /* Hidden by default */
            flex-direction: column; gap: 10px;
            width: 160px;
        }
        .volume-control {
            display: flex; align-items: center; gap: 10px; color: #fff; font-size: 12px;
        }
        input[type=range] {
            width: 80px; accent-color: #00e5ff;
        }
        .mute-btn {
            background: none; border: 1px solid #ff3333; color: #ff3333;
            padding: 2px 5px; font-size: 10px; cursor: pointer; border-radius: 3px;
        }
        .mute-btn.muted { background: #ff3333; color: #000; }

        /* Bottom Controls */
        .controls-hint {
            position: absolute; bottom: 20px; width: 100%;
            text-align: center; color: rgba(255, 255, 255, 0.5);
            font-size: 12px; pointer-events: none;
        }

        /* Login Overlay */
        #login-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .title {
            font-size: 60px; color: #fff; text-transform: uppercase;
            text-shadow: 0 0 50px #00e5ff, 0 0 20px #00e5ff;
            margin-bottom: 10px; letter-spacing: 5px; text-align: center;
        }
        .subtitle {
            color: #00e5ff; font-size: 16px; letter-spacing: 8px; margin-bottom: 50px; opacity: 0.8;
        }
        .login-input {
            background: rgba(0,0,0,0.5); border: 2px solid #00e5ff;
            color: #fff; padding: 15px 25px; font-family: 'Orbitron';
            font-size: 20px; text-align: center; border-radius: 30px;
            outline: none; margin-bottom: 20px; width: 250px;
            box-shadow: 0 0 20px rgba(0,229,255,0.2);
            transition: all 0.3s;
        }
        .login-input:focus { box-shadow: 0 0 40px rgba(0,229,255,0.5); width: 280px; }
        .start-btn {
            background: #00e5ff; color: #000; border: none;
            padding: 15px 40px; font-family: 'Orbitron'; font-weight: 900;
            font-size: 18px; border-radius: 30px; cursor: pointer;
            box-shadow: 0 0 30px #00e5ff; transition: all 0.2s;
        }
        .start-btn:hover { transform: scale(1.1); box-shadow: 0 0 60px #00e5ff; background: #fff; }

        #notification {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 24px; color: #fff; text-shadow: 0 0 20px #ff0055;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }

        /* Glitch Effect Class for Noise */
        .glitch-active {
            animation: glitch-anim 0.2s infinite;
        }
        @keyframes glitch-anim {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            40% { transform: translate(-2px, -2px); filter: invert(0.2); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); filter: hue-rotate(-90deg); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>

    <!-- Game Container -->
    <div id="login-overlay">
        <div class="title">MINIROOM<br>TESSERACT 3D</div>
        <div class="subtitle">NEON MULTIPLAYER VERSE</div>
        <input type="text" id="username" class="login-input" placeholder="CODENAME" maxlength="10">
        <button class="start-btn" onclick="startGame()">CONNECT</button>
    </div>

    <div id="ui-layer">
        <div class="hud-left-container">
            <!-- Main Stats -->
            <div class="stats-box">
                <div class="stat-row"><span>SCORE</span><span id="score-val" class="stat-val">0</span></div>
                <div class="stat-row"><span>TAIL</span><span id="tail-val" class="stat-val">0</span></div>
                
                <div class="gauge-group">
                    <div class="progress-bar"><div id="red-fill" class="progress-fill" style="background:#ff3333; box-shadow:0 0 8px #ff3333;"></div></div>
                    <div class="progress-bar"><div id="yel-fill" class="progress-fill" style="background:#ffff33; box-shadow:0 0 8px #ffff33;"></div></div>
                    <div class="progress-bar"><div id="blu-fill" class="progress-fill" style="background:#3388ff; box-shadow:0 0 8px #3388ff;"></div></div>
                </div>

                <div class="user-count">USER (<span id="players-val">1</span>)</div>
                
                <div id="skill-timer" class="skill-status" style="display:none">DIGESTING...</div>
                <div id="skill-cd" class="skill-status" style="color: #666; display:none">CD: 60s</div>
            </div>
            
            <!-- Advanced Stats -->
            <div class="stats-box">
                <div class="stat-row"><span class="stat-ap">AP</span><span id="ap-val" class="stat-val">0.000</span></div>
                <div class="stat-row"><span class="stat-cp">CP</span><span id="cp-val" class="stat-val">0.0000</span></div>
                <div class="stat-row"><span class="stat-wp">WP</span><span id="wp-val" class="stat-val">0</span></div>
                <div class="stat-row" style="margin-top:5px; border-top:1px solid rgba(255,255,255,0.1); padding-top:5px;">
                    <span class="stat-sub">Digest Count</span><span id="digest-cnt" class="stat-val stat-sub">0/10</span>
                </div>
            </div>

            <!-- Settings -->
            <button class="settings-btn" onclick="toggleSettings()">⚙ SETTINGS</button>
            <div id="settings-panel" class="settings-panel">
                <div class="volume-control">
                    <span>VOL</span>
                    <input type="range" id="bgm-vol" min="0" max="1" step="0.1" value="0.5" oninput="updateVolume(this.value)">
                </div>
                <div style="text-align: right;">
                    <button id="mute-btn" class="mute-btn" onclick="toggleMute()">MUTE</button>
                </div>
            </div>
        </div>

        <div class="controls-hint">
            [MOUSE] Move | [SPACE] Boost | [Q] Digest (1min CD)
        </div>
        <div id="notification"></div>
    </div>

    <!-- Import Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import * as THREE from 'three';

        // --- BGM SETUP ---
        // TODO: 아래 URL을 본인의 깃허브 원본 주소(Raw)로 변경하세요.
        // 예: 'https://raw.githubusercontent.com/User/Repo/main/BGM.mp3'
        const BGM_URL = 'https://github.com/Soundcode808/Mini-Room-Project/blob/main/BGM.mp3'; 
        let bgmAudio = new Audio();
        bgmAudio.loop = true;
        bgmAudio.volume = 0.5;

        // --- FIREBASE SETUP ---
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'miniroom-3d-tesseract';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let db, auth, currentUser, myDocRef;
        let isOnline = false;

        async function initFirebase() {
            if (!firebaseConfig) return;
            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);

            if (initialAuthToken) {
                await signInWithCustomToken(auth, initialAuthToken);
            } else {
                await signInAnonymously(auth);
            }
            
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    isOnline = true;
                    myDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid);
                    setupNetworkListeners();
                }
            });
        }

        const CONFIG = {
            worldSize: 600,
            camHeight: 150, 
            camOffset: 150, 
            speed: 0.9,
            boostSpeed: 1.8,
            npcCount: 5,
            tailOverlap: 0.5, 
            tailSize: 3.5,
            cubes: {
                large: { color: 0xff3333, size: 3.0, required: 5, points: 30 },
                medium: { color: 0xffff33, size: 2.0, required: 10, points: 20 },
                small: { color: 0x3388ff, size: 1.2, required: 15, points: 10 }
            },
            skillDuration: 5000,
            skillCooldown: 60000, // 1분
            digestInterval: 1000,
            fixedY: 3.0,
            collisionDebuffTime: 3000 // 3초
        };

        let scene, camera, renderer, composer, bloomPass;
        let player;
        let npcs = [];
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
        
        const cubes = [];
        const remotePlayers = {}; 
        const particles = [];
        
        let score = 0;
        let frameCount = 0;
        let isBoost = false;
        let eatenCounts = { large: 0, medium: 0, small: 0 };

        let stats = {
            ap: 0, cp: 0, wp: 0, digestCount: 0,
            apTimer: 0, tailBuffTimer: 0
        };

        let skillState = {
            active: false, lastDigest: 0, endTime: 0, cooldownUntil: 0
        };

        // Collision Debuff State
        let debuffState = {
            active: false,
            endTime: 0
        };

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.0015);

            camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 1, 2000);
            camera.rotation.order = 'YXZ'; 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0; 
            bloomPass.strength = 2.5; 
            bloomPass.radius = 0.8;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            const ambient = new THREE.AmbientLight(0x404040, 2.0); 
            scene.add(ambient);
            
            const gridHelper = new THREE.GridHelper(CONFIG.worldSize * 2, 80, 0x00ffff, 0x0044aa);
            gridHelper.position.y = 0;
            gridHelper.material.opacity = 0.5;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            const subGrid = new THREE.GridHelper(CONFIG.worldSize * 2, 400, 0x4400ff, 0x110033);
            subGrid.position.y = -0.1; 
            subGrid.material.opacity = 0.2;
            subGrid.material.transparent = true;
            scene.add(subGrid);
            
            createPlayer();
            for(let i=0; i<CONFIG.npcCount; i++) createNPC();
            for(let i=0; i<60; i++) spawnCube();

            window.addEventListener('resize', onResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mousedown', () => { isBoost = true; });
            window.addEventListener('mouseup', () => { isBoost = false; });
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', (e) => { if(e.code === 'Space') isBoost = false; });

            animate();
            updateHUD();
        }

        // --- MESH FACTORY ---
        function createWireframeMesh(geometry, color) {
            const wireframe = new THREE.WireframeGeometry(geometry);
            const line = new THREE.LineSegments(wireframe);
            line.material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0, 
                depthTest: true
            });
            return line;
        }

        function createPlayerMesh(color = 0x0088ff, coreColor = 0x00ffff) {
            const group = new THREE.Group();

            // 1. 외부 그리드 구체
            const outerGeo = new THREE.IcosahedronGeometry(3.0, 3);
            const outerMesh = createWireframeMesh(outerGeo, color);
            group.add(outerMesh);

            // 1-1. 외곽 하얀 라인 (White Outline) - Scale을 약간 키워 외곽선 효과
            const rimGeo = new THREE.IcosahedronGeometry(3.1, 1);
            const rimMesh = createWireframeMesh(rimGeo, 0xffffff);
            rimMesh.material.opacity = 0.4;
            group.add(rimMesh);

            // 2. 내부 그리드 구체
            const midGeo = new THREE.IcosahedronGeometry(2.2, 1);
            const midMesh = createWireframeMesh(midGeo, coreColor);
            group.add(midMesh);

            // 3. 블랙홀 굴절 효과 (Enhanced Black Hole)
            // 크기를 키워 영향력 범위를 시각화 (3.5 -> 5.0)
            const distGeo = new THREE.SphereGeometry(5.0, 32, 32);
            const distMat = new THREE.MeshPhysicalMaterial({
                color: 0x88ccff, 
                metalness: 0.1,
                roughness: 0,
                transmission: 1.0, // 완전 투과
                thickness: 3.0,
                ior: 2.0, // 굴절률 증가 (더 강한 왜곡)
                transparent: true,
                opacity: 0.1, 
                side: THREE.DoubleSide
            });
            const distMesh = new THREE.Mesh(distGeo, distMat);
            group.add(distMesh);

            // 4. 핵
            const coreGeo = new THREE.SphereGeometry(1.2, 32, 32); 
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const coreMesh = new THREE.Mesh(coreGeo, coreMat);
            
            const light = new THREE.PointLight(coreColor, 10, 50); 
            coreMesh.add(light);
            group.add(coreMesh);

            group.userData = {
                outer: outerMesh,
                rim: rimMesh,
                mid: midMesh,
                core: coreMesh,
                baseColor: new THREE.Color(color),
                rotSpeed: 0.02
            };

            return group;
        }

        function createTailMesh(size, color) {
            const group = new THREE.Group();
            
            const geo1 = new THREE.BoxGeometry(size, size, size);
            const mesh1 = createWireframeMesh(geo1, color);
            
            const coreGeo = new THREE.BoxGeometry(size * 0.3, size * 0.3, size * 0.3);
            const coreMat = new THREE.MeshBasicMaterial({ color: color });
            const coreMesh = new THREE.Mesh(coreGeo, coreMat);

            group.add(mesh1);
            group.add(coreMesh);
            
            return group;
        }

        function createPlayer() {
            const mesh = createPlayerMesh();
            mesh.position.y = CONFIG.fixedY; 
            scene.add(mesh);
            
            player = {
                mesh: mesh,
                velocity: new THREE.Vector3(),
                path: [], 
                tailMeshes: [],
                color: 0x00ffff,
                username: "Player"
            };
        }

        function createNPC() {
            const mesh = createPlayerMesh(0xff8800, 0xffaa00); 
            mesh.position.y = CONFIG.fixedY;
            
            const range = CONFIG.worldSize / 2;
            mesh.position.x = (Math.random() - 0.5) * range;
            mesh.position.z = (Math.random() - 0.5) * range;
            
            scene.add(mesh);

            npcs.push({
                mesh: mesh,
                velocity: new THREE.Vector3(),
                path: [],
                tailMeshes: [],
                target: null,
                speed: CONFIG.speed * 0.8,
                changeTargetTime: 0
            });
        }

        function createRemotePlayer(id, data) {
            const mesh = createPlayerMesh(); 
            mesh.position.y = CONFIG.fixedY;
            scene.add(mesh);
            return {
                mesh: mesh,
                tailMeshes: [],
                targetPos: new THREE.Vector3(data.x || 0, CONFIG.fixedY, data.y || 0)
            };
        }

        function spawnCube(posOverride = null) {
            const range = CONFIG.worldSize / 2;
            const x = posOverride ? posOverride.x : (Math.random() - 0.5) * 2 * range;
            const z = posOverride ? posOverride.z : (Math.random() - 0.5) * 2 * range;
            
            const rand = Math.random();
            let type, config;
            if (rand < 0.2) { type = 'large'; config = CONFIG.cubes.large; }
            else if (rand < 0.5) { type = 'medium'; config = CONFIG.cubes.medium; }
            else { type = 'small'; config = CONFIG.cubes.small; }

            const geometry = new THREE.BoxGeometry(config.size, config.size, config.size);
            const mesh = createWireframeMesh(geometry, config.color);
            mesh.position.set(x, config.size/2, z);
            
            const core = new THREE.Mesh(
                new THREE.BoxGeometry(config.size*0.4, config.size*0.4, config.size*0.4),
                new THREE.MeshBasicMaterial({ color: config.color })
            );
            mesh.add(core);

            mesh.userData = { type: type, points: config.points, color: config.color };
            scene.add(mesh);
            cubes.push({ mesh: mesh, rotateSpeed: Math.random() * 0.05 + 0.02 });
        }

        function createExplosion(pos, color, count=8) {
            for(let i=0; i<count; i++) {
                const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const vel = new THREE.Vector3(
                    Math.random()-0.5, (Math.random()-0.5)*0.5, Math.random()-0.5 
                ).normalize().multiplyScalar(0.5 + Math.random());
                
                scene.add(mesh);
                particles.push({ mesh, vel, life: 1.0 });
            }
        }

        function handleKeyDown(e) {
            if (e.code === 'Space') isBoost = true;
            if (e.code === 'KeyQ' || e.code === 'Keyq') {
                activateSkill();
            }
        }

        function activateSkill() {
            const now = Date.now();
            if (skillState.active) return;
            if (now < skillState.cooldownUntil) {
                showNotification(`SKILL ON COOLDOWN`);
                return;
            }

            skillState.active = true;
            skillState.endTime = now + CONFIG.skillDuration;
            skillState.cooldownUntil = now + CONFIG.skillCooldown; 
            showNotification("DIGESTION SKILL ACTIVATED!");
            
            player.mesh.userData.outer.material.color.setHex(0xff0055);
        }

        // --- GAME LOGIC ---
        function applyCollisionDebuff() {
            debuffState.active = true;
            debuffState.endTime = Date.now() + CONFIG.collisionDebuffTime;
            document.body.classList.add('glitch-active'); // 화면 노이즈 효과
            showNotification("SYSTEM ERROR: SENSORS OFFLINE");
        }

        function scatterTails(entity) {
            const count = Math.floor(entity.tailMeshes.length / 2);
            if(count === 0) return;

            for(let i=0; i<count; i++) {
                // 꼬리 끝에서부터 제거
                const tail = entity.tailMeshes.pop();
                if(tail) {
                    scene.remove(tail); // 일단 꼬리 메쉬 제거
                    
                    // 해당 위치에 큐브 생성 (흩뿌리기)
                    spawnCube(tail.position);
                    // 큐브 생성 후 약간 튕겨나가는 효과를 주면 좋지만, spawnCube는 정적임.
                    // 간단히 파티클 효과로 대체
                    createExplosion(tail.position, 0xffffff, 5);
                }
            }
            if(entity === player) updateHUD();
        }

        let lastTime = Date.now();
        function animate() {
            requestAnimationFrame(animate);
            frameCount++;
            const now = Date.now();
            const deltaTime = (now - lastTime) / 1000;
            lastTime = now;

            // Debuff Check
            if (debuffState.active && now > debuffState.endTime) {
                debuffState.active = false;
                document.body.classList.remove('glitch-active');
                showNotification("SYSTEM RESTORED");
            }

            if (player) {
                // Skill Logic
                if (skillState.active) {
                    if (now > skillState.endTime) {
                        skillState.active = false;
                        player.mesh.userData.outer.material.color.setHex(0x0088ff);
                        showNotification("SKILL ENDED");
                    } else {
                        if (now - skillState.lastDigest > CONFIG.digestInterval) {
                            if (player.tailMeshes.length > 0) {
                                const tail = player.tailMeshes.pop();
                                scene.remove(tail);
                                score += 50;
                                skillState.lastDigest = now;
                                createExplosion(player.mesh.position, 0xff0055, 5);
                                let cpGain = 0.0001;
                                if (stats.tailBuffTimer >= 30) cpGain += 0.0001;
                                gainCP(cpGain);
                                checkWP(1);
                                updateHUD();
                            }
                        }
                    }
                }

                // Stats Logic
                updateAP(deltaTime);
                updateCP(deltaTime);

                // Move
                raycaster.setFromCamera(mouse, camera);
                const intersect = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersect);
                
                const dir = new THREE.Vector3().subVectors(intersect, player.mesh.position);
                dir.y = 0;
                
                const speedRatio = player.velocity.length() / CONFIG.boostSpeed;
                const glowColor = player.mesh.userData.baseColor.clone();
                glowColor.lerp(new THREE.Color(0xffffff), speedRatio * 0.8);
                player.mesh.userData.outer.material.color.copy(glowColor);
                
                if (dir.length() > 1) {
                    dir.normalize();
                    const currentSpeed = isBoost ? CONFIG.boostSpeed : CONFIG.speed;
                    player.velocity.add(dir.multiplyScalar(0.1)); 
                }
                
                player.velocity.multiplyScalar(0.9);
                player.mesh.position.add(player.velocity);
                
                player.mesh.position.y = CONFIG.fixedY;
                player.velocity.y = 0;
                
                const limit = CONFIG.worldSize / 2;
                player.mesh.position.x = Math.max(-limit, Math.min(limit, player.mesh.position.x));
                player.mesh.position.z = Math.max(-limit, Math.min(limit, player.mesh.position.z));

                // Camera
                camera.position.set(
                    player.mesh.position.x, 
                    CONFIG.camHeight, 
                    player.mesh.position.z + CONFIG.camOffset
                );
                camera.lookAt(player.mesh.position.x, 0, player.mesh.position.z);

                // Anim
                const ud = player.mesh.userData;
                ud.outer.rotation.y += ud.rotSpeed;
                ud.outer.rotation.z += ud.rotSpeed * 0.5;
                ud.rim.rotation.y += ud.rotSpeed * 0.8; // Rim rotate
                ud.mid.rotation.y -= ud.rotSpeed * 1.5;

                player.path.unshift(player.mesh.position.clone());
                if (player.path.length > 500) player.path.pop();

                updateTail(player);
                updateNPCs();
                checkEntityCollisions();
                checkTailSnatching(); 
                
                if (frameCount % 5 === 0 && isOnline) uploadState();
            }

            for (const uid in remotePlayers) {
                const rp = remotePlayers[uid];
                rp.mesh.position.lerp(rp.targetPos, 0.15);
                rp.mesh.position.y = CONFIG.fixedY; 
                rp.mesh.userData.outer.rotation.y += 0.02;
                if (!rp.path) rp.path = [];
                rp.path.unshift(rp.mesh.position.clone());
                if (rp.path.length > 500) rp.path.pop();
                updateTail(rp);
            }

            processCubes(player);
            updateEffects();

            composer.render();
            updateSkillHUD(now);
        }

        function updateNPCs() {
            npcs.forEach(npc => {
                if (!npc.target || Math.random() < 0.02) { 
                    let minDist = Infinity;
                    let closest = null;
                    cubes.forEach(c => {
                        const d = npc.mesh.position.distanceTo(c.mesh.position);
                        if (d < minDist) { minDist = d; closest = c; }
                    });
                    npc.target = closest;
                }
                if (npc.target) {
                    const dir = new THREE.Vector3().subVectors(npc.target.mesh.position, npc.mesh.position).normalize();
                    npc.velocity.add(dir.multiplyScalar(0.08)); 
                }
                npc.velocity.multiplyScalar(0.9);
                npc.mesh.position.add(npc.velocity);
                npc.mesh.position.y = CONFIG.fixedY; 
                npc.velocity.y = 0;
                
                const limit = CONFIG.worldSize / 2;
                if(npc.mesh.position.x < -limit || npc.mesh.position.x > limit) npc.velocity.x *= -1;
                if(npc.mesh.position.z < -limit || npc.mesh.position.z > limit) npc.velocity.z *= -1;
                npc.mesh.position.x = Math.max(-limit, Math.min(limit, npc.mesh.position.x));
                npc.mesh.position.z = Math.max(-limit, Math.min(limit, npc.mesh.position.z));
                
                npc.mesh.userData.outer.rotation.y += 0.02;
                npc.path.unshift(npc.mesh.position.clone());
                if (npc.path.length > 500) npc.path.pop();
                updateTail(npc);
                processCubes(npc);
            });
        }

        function processCubes(entity) {
            if (entity === player && debuffState.active) return; // 디버프 시 획득 불가

            entity.mesh.updateMatrixWorld();
            for (let i = cubes.length - 1; i >= 0; i--) {
                const c = cubes[i];
                
                // 회전 애니메이션 복구
                c.mesh.rotation.x += c.rotateSpeed;
                c.mesh.rotation.y += c.rotateSpeed;

                const dist = entity.mesh.position.distanceTo(c.mesh.position);
                
                if (dist < 30) {
                    c.mesh.position.lerp(entity.mesh.position, 0.25);
                    c.mesh.position.y = THREE.MathUtils.lerp(c.mesh.position.y, entity.mesh.position.y, 0.1);
                }

                if (dist < 5.0) { 
                    createExplosion(c.mesh.position, c.mesh.userData.color);
                    scene.remove(c.mesh);
                    cubes.splice(i, 1);
                    
                    if (entity === player) {
                        const type = c.mesh.userData.type;
                        score += c.mesh.userData.points;
                        eatenCounts[type]++;
                        if (eatenCounts[type] >= CONFIG.cubes[type].required) {
                            addTailSegment(player, c.mesh.userData.color);
                            eatenCounts[type] = 0; 
                        }
                        updateHUD();
                    } else {
                        if (Math.random() < 0.3) addTailSegment(entity, c.mesh.userData.color);
                    }
                    
                    spawnCube();
                }
            }
        }

        function checkEntityCollisions() {
            npcs.forEach(npc => {
                const dist = player.mesh.position.distanceTo(npc.mesh.position);
                if (dist < 8.0) { 
                    const midPoint = new THREE.Vector3().addVectors(player.mesh.position, npc.mesh.position).multiplyScalar(0.5);
                    createExplosion(midPoint, 0xffffff, 15);

                    const pushDir = new THREE.Vector3().subVectors(player.mesh.position, npc.mesh.position);
                    pushDir.y = 0; 
                    pushDir.normalize();

                    player.velocity.add(pushDir.multiplyScalar(4.0));
                    npc.velocity.add(pushDir.multiplyScalar(-4.0));
                    
                    // Collision Penalty
                    scatterTails(player);
                    scatterTails(npc);
                    applyCollisionDebuff();

                    gainCP(0.0001); 
                }
            });
        }

        function checkTailSnatching() {
            npcs.forEach(npc => {
                for (let i = 0; i < npc.tailMeshes.length; i++) {
                    const tail = npc.tailMeshes[i];
                    const dist = player.mesh.position.distanceTo(tail.position);
                    if (dist < 4.0) {
                        createExplosion(tail.position, 0xff00ff, 15);
                        scene.remove(tail);
                        npc.tailMeshes.splice(i, 1); 
                        addTailSegment(player, 0xff00ff);
                        gainCP(0.0001); 
                        showNotification("TAIL SNATCHED!");
                        break; 
                    }
                }
            });
        }

        function updateEffects() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel);
                p.life -= 0.03;
                p.mesh.scale.setScalar(p.life);
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }
        }

        function updateTail(entity) {
            if (entity.tailMeshes.length === 0 || entity.path.length < 2) return;
            let currentPathIdx = 0;
            const targetDist = CONFIG.tailSize * CONFIG.tailOverlap; 
            for (let i = 0; i < entity.tailMeshes.length; i++) {
                const tailMesh = entity.tailMeshes[i];
                let foundPos = null;
                let distAccum = 0;
                for (let j = currentPathIdx; j < entity.path.length - 1; j++) {
                    const p1 = entity.path[j];
                    const p2 = entity.path[j+1];
                    const d = p1.distanceTo(p2);
                    if (distAccum + d >= targetDist) {
                        const remaining = targetDist - distAccum;
                        const ratio = remaining / d;
                        foundPos = new THREE.Vector3().lerpVectors(p1, p2, ratio);
                        currentPathIdx = j; 
                        break;
                    }
                    distAccum += d;
                }
                if (foundPos) {
                    tailMesh.position.copy(foundPos);
                    tailMesh.position.y = CONFIG.fixedY; 
                    tailMesh.rotation.x += 0.05; tailMesh.rotation.z += 0.05;
                } else {
                    tailMesh.position.copy(entity.path[entity.path.length-1]);
                }
            }
        }

        function addTailSegment(entity, color) {
            const mesh = createTailMesh(CONFIG.tailSize, color || 0x00ffff);
            mesh.position.copy(entity.mesh.position);
            scene.add(mesh);
            entity.tailMeshes.push(mesh);
            if(entity === player) updateHUD();
        }

        function updateHUD() {
            document.getElementById('score-val').innerText = score;
            if (player) {
                document.getElementById('tail-val').innerText = player.tailMeshes.length;
            }
            const redPct = (eatenCounts.large / CONFIG.cubes.large.required) * 100;
            document.getElementById('red-fill').style.width = `${redPct}%`;
            const yelPct = (eatenCounts.medium / CONFIG.cubes.medium.required) * 100;
            document.getElementById('yel-fill').style.width = `${yelPct}%`;
            const bluPct = (eatenCounts.small / CONFIG.cubes.small.required) * 100;
            document.getElementById('blu-fill').style.width = `${bluPct}%`;
        }

        function updateAP(deltaTime) {
            const speed = player.velocity.length();
            if (speed > CONFIG.speed * 1.5) { 
                stats.apTimer += deltaTime;
                if (stats.apTimer >= 0.5) {
                    stats.ap += 0.001;
                    stats.apTimer = 0;
                    updateHUDStats();
                }
            } else {
                stats.apTimer = 0;
            }
        }

        function updateCP(deltaTime) {
            if (player.tailMeshes.length >= 6) {
                stats.tailBuffTimer += deltaTime;
            } else {
                stats.tailBuffTimer = 0;
            }
        }

        function gainCP(amount = 0.0001) {
            stats.cp += amount;
            updateHUDStats();
        }

        function checkWP(digestedAmount = 1) {
            stats.digestCount += digestedAmount;
            if (stats.digestCount >= 10) {
                const costAP = 0.1;
                const costCP = 0.01;
                if (stats.ap >= costAP && stats.cp >= costCP) {
                    stats.ap -= costAP;
                    stats.cp -= costCP;
                    stats.wp += 1;
                    stats.digestCount -= 10; 
                    showNotification("WP GAINED!");
                }
            }
            updateHUDStats();
        }

        function updateHUDStats() {
            document.getElementById('ap-val').innerText = stats.ap.toFixed(3);
            document.getElementById('cp-val').innerText = stats.cp.toFixed(4);
            document.getElementById('wp-val').innerText = stats.wp;
            document.getElementById('digest-cnt').innerText = `${stats.digestCount}/10`;
        }

        function updateSkillHUD(now) {
            const timerEl = document.getElementById('skill-timer');
            const cdEl = document.getElementById('skill-cd');

            if (skillState.active) {
                timerEl.style.display = 'block';
                cdEl.style.display = 'none';
                const remain = Math.ceil((skillState.endTime - now)/1000);
                timerEl.innerText = `DIGESTING... ${remain}`;
            } else if (now < skillState.cooldownUntil) {
                timerEl.style.display = 'none';
                cdEl.style.display = 'block';
                const cd = Math.ceil((skillState.cooldownUntil - now)/1000);
                cdEl.innerText = `CD: ${Math.floor(cd/60)}m ${cd%60}s`;
            } else {
                timerEl.style.display = 'none';
                cdEl.style.display = 'none';
            }
        }

        function uploadState() {
            if (!myDocRef) return;
            setDoc(myDocRef, {
                x: player.mesh.position.x,
                y: player.mesh.position.z, 
                score: score,
                tailCount: player.tailMeshes.length,
                timestamp: serverTimestamp()
            }).catch(e => console.error(e));
        }

        function setupNetworkListeners() {
            const playersRef = collection(db, 'artifacts', appId, 'public', 'data', 'players');
            onSnapshot(playersRef, (snapshot) => {
                const count = snapshot.size;
                document.getElementById('players-val').innerText = count;

                snapshot.docChanges().forEach((change) => {
                    const uid = change.doc.id;
                    if (uid === currentUser.uid) return;
                    const data = change.doc.data();
                    if (change.type === 'added') {
                        remotePlayers[uid] = createRemotePlayer(uid, data);
                    }
                    if (change.type === 'modified') {
                        if (remotePlayers[uid]) {
                            remotePlayers[uid].targetPos.set(data.x, 0, data.y);
                            const diff = (data.tailCount || 0) - remotePlayers[uid].tailMeshes.length;
                            if (diff > 0) {
                                for(let k=0; k<diff; k++) addTailSegment(remotePlayers[uid], 0xff0055);
                            }
                        }
                    }
                    if (change.type === 'removed') {
                        if (remotePlayers[uid]) {
                            scene.remove(remotePlayers[uid].mesh);
                            remotePlayers[uid].tailMeshes.forEach(m => scene.remove(m));
                            delete remotePlayers[uid];
                        }
                    }
                });
            });
            window.addEventListener('beforeunload', () => { deleteDoc(myDocRef); });
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        // --- GLOBAL UI FUNCTIONS ---
        window.toggleSettings = function() {
            const panel = document.getElementById('settings-panel');
            panel.style.display = panel.style.display === 'flex' ? 'none' : 'flex';
        };

        window.updateVolume = function(val) {
            bgmAudio.volume = parseFloat(val);
        };

        window.toggleMute = function() {
            bgmAudio.muted = !bgmAudio.muted;
            const btn = document.getElementById('mute-btn');
            if(bgmAudio.muted) {
                btn.classList.add('muted');
                btn.innerText = "UNMUTE";
            } else {
                btn.classList.remove('muted');
                btn.innerText = "MUTE";
            }
        };

        window.startGame = function() {
            const username = document.getElementById('username').value || "Player";
            document.getElementById('login-overlay').style.display = 'none';
            if(player) player.username = username;
            
            init3D();
            initFirebase();
            
            // Try to play audio (requires user interaction first)
            bgmAudio.src = BGM_URL;
            bgmAudio.play().catch(e => console.log("Audio autoplay blocked, will play on interaction"));
            
            showNotification(`WELCOME, ${username}`);
        };

        function showNotification(msg) {
            const el = document.getElementById('notification');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

    </script>
</body>
</html>
