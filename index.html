<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Miniroom: Reboot v3.1 (Multiplayer Fix)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

        body {
            margin: 0; overflow: hidden;
            background-color: #020205; color: #fff;
            font-family: 'Noto Sans KR', sans-serif;
            touch-action: none; user-select: none;
        }

        #gameCanvas { display: block; width: 100vw; height: 100vh; }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 24px; box-sizing: border-box;
            z-index: 10; display: none; /* Hidden until login */
        }

        /* Login Screen */
        #login-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000;
        }
        .title-main { font-family: 'Orbitron'; font-size: 4rem; color: #00e5ff; text-shadow: 0 0 50px rgba(0,229,255,0.8); margin-bottom: 10px; }
        .title-sub { font-family:'Orbitron'; color:#fff; font-size:1rem; opacity:0.7; letter-spacing:5px; margin-bottom: 50px; }
        
        .login-box {
            background: rgba(10, 20, 30, 0.9); border: 2px solid #00e5ff;
            padding: 30px; border-radius: 10px; text-align: center;
            box-shadow: 0 0 30px rgba(0,229,255,0.2);
        }
        #username-input {
            background: rgba(0,0,0,0.5); border: 1px solid #555; color: #fff;
            padding: 12px; font-size: 16px; font-family: 'Noto Sans KR';
            width: 200px; margin-bottom: 20px; text-align: center; outline: none;
            border-radius: 4px;
        }
        #username-input:focus { border-color: #00e5ff; }
        
        .start-btn {
            padding: 12px 40px; background: #00e5ff; border: none;
            color: #000; font-family: 'Orbitron'; font-size: 18px; font-weight: 700;
            cursor: pointer; transition: all 0.2s; border-radius: 4px;
        }
        .start-btn:hover { background: #fff; box-shadow: 0 0 20px #00e5ff; }

        /* HUD */
        .hud-left-container {
            position: absolute; top: 24px; left: 24px;
            display: flex; flex-direction: column; gap: 10px;
            pointer-events: none;
        }

        .status-panel {
            pointer-events: auto; background: rgba(5, 10, 20, 0.9);
            border: 1px solid rgba(0, 229, 255, 0.3); border-left: 4px solid #00e5ff;
            padding: 20px; border-radius: 4px; min-width: 260px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            font-family: 'Orbitron', sans-serif;
        }

        .stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; font-size: 12px; }
        .label { color: #88aadd; font-size: 10px; }
        .value { color: #fff; font-weight: 700; }
        .bar-container { width: 100%; height: 4px; background: #222; margin-bottom: 8px; border-radius: 2px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.1s; }
        .wp-fill { background: linear-gradient(90deg, #aa00ff, #d500f9); }
        .aura-fill { background: linear-gradient(90deg, #ff6d00, #ffea00); }
        .stamina-fill { background: linear-gradient(90deg, #00c853, #64dd17); }

        #minimap-container {
            position: absolute; top: 24px; right: 24px;
            width: 180px; height: 180px; border-radius: 50%;
            border: 2px solid #00e5ff; background: rgba(0,0,0,0.8);
            overflow: hidden; pointer-events: none;
        }
        #minimapCanvas { width: 100%; height: 100%; }

        /* Controls */
        #digest-btn {
            pointer-events: auto; position: absolute; bottom: 120px; right: 30px;
            width: 60px; height: 60px; border-radius: 50%;
            border: 2px solid #00c853; background: rgba(0,0,0,0.6); color: #00c853;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(4px); font-size: 24px;
            transition: all 0.1s;
        }
        #digest-btn:active { transform: scale(0.9); background: rgba(0,200,83,0.3); }

        #aura-refill-btn {
            pointer-events: auto; position: absolute; bottom: 30px; right: 30px;
            width: 70px; height: 70px; border-radius: 50%; 
            border: 2px solid #ff9100; background: rgba(0,0,0,0.6); color: #ff9100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; backdrop-filter: blur(4px);
        }
        #aura-refill-btn:active { transform: scale(0.95); }
        
        #notification {
            position: absolute; top: 20%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; text-align: center; font-family: 'Orbitron'; font-weight: 900;
            font-size: 28px; color: #fff; text-shadow: 0 0 20px #00e5ff;
            pointer-events: none; opacity: 0; transition: opacity 0.3s;
        }

        .key-guide { position: absolute; bottom: 30px; left: 30px; color: #667; font-size: 11px; font-family: 'Orbitron'; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Login Screen -->
    <div id="login-overlay">
        <h1 class="title-main">MINIROOM</h1>
        <h2 class="title-sub">MULTIPLAYER ONLINE</h2>
        <div class="login-box">
            <input type="text" id="username-input" placeholder="ENTER CODENAME" maxlength="12">
            <br>
            <button class="start-btn" onclick="app.joinGame()">CONNECT</button>
        </div>
    </div>

    <!-- Game UI -->
    <div id="ui-layer">
        <div class="hud-left-container">
            <div class="status-panel">
                <div class="stat-row"><span class="label">WP</span><span class="value"><span id="wp-val">0</span></span></div>
                <div class="bar-container"><div id="wp-bar" class="bar-fill wp-fill"></div></div>
                <div class="stat-row"><span class="label">Aura</span><span class="value" id="aura-text">100%</span></div>
                <div class="bar-container"><div id="aura-bar" class="bar-fill aura-fill"></div></div>
                <div class="stat-row"><span class="label">Stamina</span><span class="value" id="stamina-text">100%</span></div>
                <div class="bar-container"><div id="stamina-bar" class="bar-fill stamina-fill"></div></div>
                <div style="font-size:10px; color:#888; margin-top:5px;">ONLINE PLAYERS: <span id="player-count" style="color:#00e5ff">1</span></div>
            </div>
        </div>

        <div id="minimap-container">
            <canvas id="minimapCanvas" width="180" height="180"></canvas>
        </div>

        <div id="notification"></div>
        <div class="key-guide">[WASD] Move &nbsp; [Space/.] Digest &nbsp; [Shift] Drift</div>

        <div id="digest-btn" onclick="app.activateDigestion()">♻</div>
        <div id="aura-refill-btn" onclick="app.refillAura()">
            <span style="font-size:24px">⚡</span><span style="font-size:10px">1 WP</span>
        </div>
    </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, collection, doc, setDoc, onSnapshot, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Global variables provided by the environment
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
const appId = typeof __app_id !== 'undefined' ? __app_id : 'miniroom-reboot';
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

class MiniroomApp {
    constructor() {
        this.authReady = false;
        
        // Init Firebase
        if (firebaseConfig && firebaseConfig.apiKey) {
            this.app = initializeApp(firebaseConfig);
            this.auth = getAuth(this.app);
            this.db = getFirestore(this.app);
        } else {
            console.error("Firebase config missing!");
        }

        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.mmCanvas = document.getElementById('minimapCanvas');
        this.mmCtx = this.mmCanvas.getContext('2d');
        
        this.state = 'LOGIN'; 
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.frameCount = 0;
        
        this.camera = { x: 0, y: 0, zoom: 1.0, targetZoom: 1.0 };
        this.worldRadius = 7500; 
        
        this.localPlayer = {
            x: 0, y: 0, vx: 0, vy: 0, radius: 15, color: '#ffffff',
            aura: 100, stamina: 100, maxStamina: 100,
            tail: [], path: [], username: 'Unknown',
            wp: 0, ap: 0, cp: 0
        };
        
        this.remotePlayers = {}; // { uid: {x, y, tail, username...} }
        this.cubes = []; // Local visual cubes
        this.particles = [];
        this.delayedSpawns = [];
        this.shockwaves = [];
        
        this.keys = {};
        this.mouse = { x: 0, y: 0, down: false };
        this.soundEnabled = true;
        this.lastUploadTime = 0;

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        window.addEventListener('keydown', e => this.keys[e.key] = true);
        window.addEventListener('keyup', e => {
            this.keys[e.key] = false;
            if (e.key === '.') this.activateDigestion();
        });
        window.addEventListener('wheel', e => this.camera.targetZoom = Math.max(0.9, Math.min(this.camera.targetZoom - e.deltaY*0.001, 3.0)), {passive:false});
        this.canvas.addEventListener('mousemove', e => { this.mouse.x = e.clientX-this.width/2; this.mouse.y = e.clientY-this.height/2; });
        this.canvas.addEventListener('mousedown', () => this.mouse.down = true);
        this.canvas.addEventListener('mouseup', () => this.mouse.down = false);

        this.initAudio();
        
        // Populate local cubes
        for(let i=0; i<300; i++) this.spawnCubeRandomly();

        requestAnimationFrame(() => this.loop());
    }

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    }

    initAudio() {
        this.bgm = new Audio('BGM.MP3');
        this.bgm.loop = true; 
        this.bgm.volume = 0.3;
        this.sounds = { hit: { play: ()=>{} }, pickup: { play: ()=>{} } }; 
    }

    async joinGame() {
        const input = document.getElementById('username-input');
        const username = input.value.trim().substring(0, 12) || "Player";
        this.localPlayer.username = username;
        this.localPlayer.color = `hsl(${Math.random()*360}, 70%, 60%)`;

        document.getElementById('login-overlay').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'flex';
        
        try {
            await this.bgm.play();
        } catch(e) { console.log("Audio play failed, user interaction needed"); }

        if (!this.auth) return;

        // AUTHENTICATION LOGIC (FIXED)
        try {
            if (initialAuthToken) {
                await signInWithCustomToken(this.auth, initialAuthToken);
            } else {
                await signInAnonymously(this.auth);
            }
            this.uid = this.auth.currentUser.uid;
            this.authReady = true;
            this.setupFirestore();
            this.state = 'PLAY';
            this.showNotification(`WELCOME, ${username}`);
        } catch (error) {
            console.error("Auth Failed:", error);
            this.showNotification("LOGIN ERROR");
        }
    }

    setupFirestore() {
        if (!this.uid || !this.db) return;

        const playersRef = collection(this.db, 'artifacts', appId, 'public', 'data', 'players');
        
        // Listen to other players with Error Handling
        onSnapshot(playersRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const data = change.doc.data();
                if (change.doc.id === this.uid) return; 

                if (change.type === "added" || change.type === "modified") {
                    this.remotePlayers[change.doc.id] = data;
                }
                if (change.type === "removed") {
                    delete this.remotePlayers[change.doc.id];
                }
            });
            document.getElementById('player-count').innerText = Object.keys(this.remotePlayers).length + 1;
        }, (error) => {
            console.error("Firestore Error:", error);
        });

        // Handle cleanup on unload
        window.addEventListener('beforeunload', () => {
             deleteDoc(doc(playersRef, this.uid));
        });
    }

    uploadState() {
        if (!this.authReady || !this.uid || Date.now() - this.lastUploadTime < 100) return; 
        
        const p = this.localPlayer;
        const simplifiedTail = p.tail.map(t => ({x: Math.round(t.x), y: Math.round(t.y)}));
        
        setDoc(doc(this.db, 'artifacts', appId, 'public', 'data', 'players', this.uid), {
            x: Math.round(p.x), y: Math.round(p.y),
            username: p.username,
            color: p.color,
            tail: simplifiedTail,
            timestamp: serverTimestamp()
        }).catch(e => {});

        this.lastUploadTime = Date.now();
    }

    loop() {
        this.frameCount++;
        this.ctx.fillStyle = '#020205';
        this.ctx.fillRect(0,0,this.width,this.height);

        if (this.state === 'PLAY') {
            this.update();
            this.uploadState();
        }

        this.ctx.save();
        this.ctx.translate(this.width/2, this.height/2);
        
        if(this.shake > 0) {
            this.ctx.translate((Math.random()-0.5)*this.shake, (Math.random()-0.5)*this.shake);
            this.shake *= 0.9;
        }

        this.camera.zoom += (this.camera.targetZoom - this.camera.zoom) * 0.1;
        this.ctx.scale(this.camera.zoom, this.camera.zoom);
        this.ctx.scale(1, 0.55); // Tilt
        this.ctx.translate(-this.localPlayer.x, -this.localPlayer.y);

        this.draw();
        
        this.ctx.restore();

        this.drawMinimap();

        requestAnimationFrame(() => this.loop());
    }

    update() {
        const p = this.localPlayer;
        
        // 1. Physics & Input
        let ax = 0, ay = 0;
        
        if (this.keys['ArrowUp'] || this.keys['w']) ay -= 1;
        if (this.keys['ArrowDown'] || this.keys['s']) ay += 1;
        if (this.keys['ArrowLeft'] || this.keys['a']) ax -= 1;
        if (this.keys['ArrowRight'] || this.keys['d']) ax += 1;
        
        if (this.mouse.down) {
            const ang = Math.atan2(this.mouse.y * 0.55, this.mouse.x);
            ax = Math.cos(ang); ay = Math.sin(ang);
        }

        p.vx += ax * 1.5; p.vy += ay * 1.5;
        p.vx *= 0.96; p.vy *= 0.96;

        let maxS = 10.8 * (1 - Math.min(p.tail.length*0.01, 0.5));
        let currS = Math.sqrt(p.vx*p.vx + p.vy*p.vy);
        if (currS > maxS) {
            p.vx *= maxS/currS; p.vy *= maxS/currS;
        }

        p.x += p.vx; p.y += p.vy;

        const dist = Math.sqrt(p.x*p.x + p.y*p.y);
        if (dist + p.radius > this.worldRadius) {
            const ang = Math.atan2(p.y, p.x);
            p.x = Math.cos(ang)*(this.worldRadius-p.radius);
            p.y = Math.sin(ang)*(this.worldRadius-p.radius);
            p.vx *= -0.5; p.vy *= -0.5;
        }

        this.updateTail(p);

        if (currS > maxS * 0.9 && this.frameCount % 10 === 0) {
            if (Math.random() < 0.3) {
                this.delayedSpawns.push({ x: p.x, y: p.y, delay: 180 });
            }
        }

        for(let i=this.delayedSpawns.length-1; i>=0; i--) {
            const d = this.delayedSpawns[i];
            d.delay--;
            if(d.delay<=0) {
                this.spawnCube(d.x, d.y);
                this.delayedSpawns.splice(i,1);
            }
        }

        for(let i=this.cubes.length-1; i>=0; i--) {
            const c = this.cubes[i];
            if(Math.abs(c.x-p.x) > 2000) continue; 
            const d = Math.sqrt((c.x-p.x)**2 + (c.y-p.y)**2);
            if(d < 200) { c.x += (p.x-c.x)*0.1; c.y += (p.y-c.y)*0.1; } // Magnet
            if(d < p.radius + 10) {
                this.addPoint(c.value);
                p.tail.push({x:p.x, y:p.y, color:c.color});
                this.cubes.splice(i,1);
            }
        }

        if (this.frameCount % 2 === 0 && this.cubes.length < 500) this.spawnCubeRandomly();

        this.checkRemoteCollisions();

        this.updateUI();
    }

    updateTail(p) {
        const spacing = 6;
        const head = {x:p.x, y:p.y};
        
        if(p.path.length===0) p.path.push(head);
        else {
            const last = p.path[0];
            if(Math.hypot(head.x-last.x, head.y-last.y) > 2) p.path.unshift(head);
        }

        let dist = 0; let segIdx = 0;
        for(let i=1; i<p.path.length-1; i++) {
            if(segIdx >= p.tail.length) break;
            const p1=p.path[i]; const p2=p.path[i+1];
            const d = Math.hypot(p1.x-p2.x, p1.y-p2.y);
            dist += d;
            while(dist >= spacing && segIdx < p.tail.length) {
                const r = (dist-spacing)/d;
                p.tail[segIdx].x = p1.x - (p1.x-p2.x)*r;
                p.tail[segIdx].y = p1.y - (p1.y-p2.y)*r;
                dist -= spacing;
                segIdx++;
            }
        }
        if(p.path.length > p.tail.length*4 + 50) p.path.pop();
    }

    checkRemoteCollisions() {
        const p = this.localPlayer;
        for(const id in this.remotePlayers) {
            const r = this.remotePlayers[id];
            if(!r.x) continue;
            
            const d = Math.hypot(p.x-r.x, p.y-r.y);
            if(d < 30) {
                this.spawnShockwave((p.x+r.x)/2, (p.y+r.y)/2);
                p.vx *= -1.2; p.vy *= -1.2; 
                this.shake = 20;
            }

            if(r.tail) {
                for(let i=2; i<r.tail.length; i++) {
                    const seg = r.tail[i];
                    if(Math.hypot(p.x-seg.x, p.y-seg.y) < 20) {
                        this.spawnParticles(seg.x, seg.y, 5, '#fff');
                    }
                }
            }

            for(let i=2; i<p.tail.length; i++) {
                const seg = p.tail[i];
                if(Math.hypot(r.x-seg.x, r.y-seg.y) < 20) {
                    const cut = p.tail.splice(i);
                    cut.forEach(c => this.spawnCube(c.x + Math.random()*20, c.y + Math.random()*20));
                    this.showNotification("TAIL CUT!");
                    this.shake = 10;
                    break;
                }
            }
        }
    }

    spawnCube(x, y) {
        this.cubes.push({x, y, size: 6, color: '#00ffff', value: 10});
    }

    spawnCubeRandomly() {
        const r = Math.random() * (this.worldRadius - 100);
        const t = Math.random() * Math.PI * 2;
        this.spawnCube(Math.cos(t)*r, Math.sin(t)*r);
    }

    spawnParticles(x, y, n, c) {
        for(let i=0; i<n; i++) {
            const a=Math.random()*Math.PI*2; const s=Math.random()*5;
            this.particles.push({x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:30, c});
        }
    }

    spawnShockwave(x, y) {
        this.shockwaves.push({x, y, r: 10, a: 1});
    }

    addPoint(v) {
        this.localPlayer.wp += v;
        if (this.localPlayer.wp > 100) this.localPlayer.wp = 100; 
    }

    activateDigestion() {
        if(this.localPlayer.tail.length > 0) {
            this.localPlayer.tail.pop();
            this.localPlayer.stamina = Math.min(100, this.localPlayer.stamina + 10);
            this.spawnParticles(this.localPlayer.x, this.localPlayer.y, 5, '#00c853'); // Visual Feedback
            this.showNotification("DIGESTING...");
        }
    }
    
    refillAura() {
        if(this.localPlayer.wp >= 1) {
            this.localPlayer.wp--;
            this.localPlayer.aura = 100;
        }
    }

    draw() {
        this.ctx.beginPath();
        this.ctx.arc(0,0,this.worldRadius,0,Math.PI*2);
        this.ctx.strokeStyle = '#ff0044';
        this.ctx.lineWidth = 20;
        this.ctx.stroke();

        this.drawGrid();

        this.ctx.globalCompositeOperation = 'lighter';
        this.cubes.forEach(c => {
             if(Math.abs(c.x - this.localPlayer.x) > 1000) return;
             this.ctx.fillStyle = c.color;
             this.ctx.beginPath(); this.ctx.arc(c.x, c.y, 6, 0, Math.PI*2); this.ctx.fill();
        });

        for(const id in this.remotePlayers) {
            const r = this.remotePlayers[id];
            this.drawPlayer(r, false);
        }

        this.drawPlayer(this.localPlayer, true);

        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 10;
        for(let i=this.shockwaves.length-1; i>=0; i--) {
            const s = this.shockwaves[i];
            s.r += 20; s.a -= 0.05;
            if(s.a <= 0) { this.shockwaves.splice(i,1); continue; }
            this.ctx.globalAlpha = s.a;
            this.ctx.beginPath(); this.ctx.arc(s.x, s.y, s.r, 0, Math.PI*2); this.ctx.stroke();
        }
        
        // Particles
        for(let i=this.particles.length-1; i>=0; i--) {
            const p = this.particles[i];
            p.x+=p.vx; p.y+=p.vy; p.life--;
            if(p.life<=0) { this.particles.splice(i,1); continue; }
            this.ctx.fillStyle = p.c;
            this.ctx.globalAlpha = p.life/30;
            this.ctx.beginPath(); this.ctx.arc(p.x, p.y, 3, 0, Math.PI*2); this.ctx.fill();
        }

        this.ctx.globalAlpha = 1;
        this.ctx.globalCompositeOperation = 'source-over';
    }

    drawGrid() {
        const spacing = 200;
        const px = this.localPlayer.x; const py = this.localPlayer.y;
        const sx = Math.floor(px/spacing)*spacing - 1000;
        const sy = Math.floor(py/spacing)*spacing - 1000;
        
        this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        for(let x=sx; x<sx+2000; x+=spacing) {
            this.ctx.moveTo(x, sy); this.ctx.lineTo(x, sy+2000);
        }
        for(let y=sy; y<sy+2000; y+=spacing) {
            this.ctx.moveTo(sx, y); this.ctx.lineTo(sx+2000, y);
        }
        this.ctx.stroke();
    }

    drawPlayer(p, isLocal) {
        if(!p.x) return;
        
        if(p.tail) {
            this.ctx.fillStyle = p.color || '#fff';
            this.ctx.globalAlpha = 0.6;
            p.tail.forEach(t => {
                this.ctx.beginPath(); this.ctx.arc(t.x, t.y, 8, 0, Math.PI*2); this.ctx.fill();
            });
        }
        this.ctx.globalAlpha = 1;

        this.ctx.fillStyle = p.color || '#fff';
        this.ctx.shadowBlur = 20; this.ctx.shadowColor = p.color;
        this.ctx.beginPath(); this.ctx.arc(p.x, p.y, p.radius || 15, 0, Math.PI*2); this.ctx.fill();
        this.ctx.shadowBlur = 0;

        if(p.username) {
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '12px Orbitron';
            this.ctx.textAlign = 'center';
            this.ctx.fillText(p.username, p.x, p.y - 30);
        }
    }

    drawMinimap() {
        const mm = this.mmCtx;
        const w = 180, h = 180;
        mm.clearRect(0,0,w,h);
        
        mm.save();
        mm.translate(w/2, h/2);
        const s = (w/2) / this.worldRadius;
        mm.scale(s, s);
        
        mm.strokeStyle='#444'; mm.lineWidth=50; 
        mm.beginPath(); mm.arc(0,0,this.worldRadius,0,Math.PI*2); mm.stroke();

        mm.fillStyle = '#ff0000';
        for(const id in this.remotePlayers) {
            const r = this.remotePlayers[id];
            mm.beginPath(); mm.arc(r.x, r.y, 100, 0, Math.PI*2); mm.fill();
        }

        mm.fillStyle = '#00ffff';
        mm.beginPath(); mm.arc(this.localPlayer.x, this.localPlayer.y, 100, 0, Math.PI*2); mm.fill();

        mm.restore();
    }

    showNotification(t) {
        const el = document.getElementById('notification');
        el.innerText = t; el.style.opacity = 1;
        setTimeout(()=>el.style.opacity=0, 2000);
    }
    
    updateUI() {
        document.getElementById('wp-val').innerText = this.localPlayer.wp;
        document.getElementById('stamina-bar').style.width = this.localPlayer.stamina + '%';
        document.getElementById('player-count').innerText = Object.keys(this.remotePlayers).length + 1;
    }
}

window.app = new MiniroomApp();
</script>
</body>
</html>
